<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://xdevil.top/feed.xml" rel="self" type="application/atom+xml" /><link href="https://xdevil.top/" rel="alternate" type="text/html" /><updated>2025-11-16T13:09:36+00:00</updated><id>https://xdevil.top/feed.xml</id><title type="html">Devil’s blog</title><subtitle>Technology summarization for personal usage.</subtitle><author><name>Devil</name><email>Devil@gmail.com</email></author><entry><title type="html">线段树（Segment Tree）</title><link href="https://xdevil.top/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2025/10/28/%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree.html" rel="alternate" type="text/html" title="线段树（Segment Tree）" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>https://xdevil.top/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2025/10/28/%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88Segment%20Tree%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2025/10/28/%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree.html"><![CDATA[<h1 id="概述">概述</h1>
<h2 id="应用场景">应用场景</h2>

<p>线段树是一种二叉树数据结构，主要用于处理区间查询和区间更新问题。</p>
<ul>
  <li>单点更新 + 区间查询</li>
  <li>区间更新 + 区间查询</li>
</ul>

<h2 id="实现方式">实现方式</h2>
<p>递归线段树:从上到下，RMQ 问题没有什么是它搞不定的，缺点效率低
<img src="/assets/content/22.png" alt="/assets/content/22.png" /></p>

<p>迭代线段树,从下到上</p>
<ul>
  <li>相较于递归线段树：效率更高，单支持区间更新场景复杂</li>
  <li>相较于树状数组：效率基本一致，应用场景没有限制，唯一缺点是空间占用大最高可达 4n
<img src="/assets/content/23.png" alt="/assets/content/23.png" /></li>
</ul>

<h1 id="单点修改--区间查询">单点修改 + 区间查询</h1>
<h2 id="迭代线段树推荐">迭代线段树（推荐）</h2>
<p>迭代线段树即可满足当前场景，且效率更高，本部分采用 zkw 线段树封装</p>

<p>支持 plus, multiple, min, max, and, or, xor, gcd, lcm 等操作, 前四者也支持浮点类型</p>

<p>支持 “设置更新（set）” 和 “增量更新（update）” 两种操作（树状数组只支持前者，故应用场景受限）</p>
<ul>
  <li>设置更新：使用一个新值替换旧值，完全移除旧有元素影响</li>
  <li>增量更新：在旧值的基础上更新为新值，旧有元素的影响没有被移除</li>
</ul>

<p>假设数组的长度是 10, 对于 [9, 3], [-5, 4], [1, 20], [-5, 30] 这些异常区间查询如何处理</p>
<ul>
  <li>默认处理：[9, 3] 这种，返回单位元即可；对于 [-5, 30] 这种，处理成 [0, 9] 即可，其他位置的元素都可以看作是单位元</li>
  <li>抛出异常：用户需要提前识别异常查询区间，并自定义该场景下的返回值，作为接口使用起来体验不佳</li>
  <li>总结：默认处理的实现是合理的，且也可以提前识别异常区间自定义返回结果，故实现采用默认处理</li>
  <li>注意：默认处理，区间 “标准化“ 过程中会有坑！！！</li>
</ul>

<p>未使用的叶子节点应该被初始化为单位元，否则可能会导致内部节点初始化错误</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Copyright (c) 2025 pk. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a MIT license</span>
<span class="c1">// if you like this code, don't delete this, thanks.</span>


<span class="c1">// identity variable template(C++14)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// std::plus partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::multiplies partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// std::bit_and partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_and</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">~</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_or partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_or</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_xor partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_xor</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// maximum partial variable template specialization</span>
<span class="c1">// std::maximum is function template, not types of functors</span>
<span class="c1">// float type should use lowest() instead of min()</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Max</span>  <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// template&lt;typename T&gt; constexpr auto identity_value&lt;Max , T&gt; = std::is_floating_point_v&lt;T&gt; ? std::numeric_limits&lt;T&gt;::lowest() : std::numeric_limits&lt;T&gt;::min();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Max</span> <span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">();</span>

<span class="c1">// minimum partial variable template specialization</span>
<span class="c1">// std::min is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Min</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Min</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

<span class="c1">// gcd partial variable template specialization</span>
<span class="c1">// std::gcd(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Gcd</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">gcd</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Gcd</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// lcm partial variable template specialization</span>
<span class="c1">// std::lcm(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Lcm</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lcm</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Lcm</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">init_value</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_tree</span><span class="p">(</span><span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// init leaf nodes</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">_tree</span><span class="p">[</span><span class="n">base</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_value</span><span class="p">;</span>

        <span class="c1">// init inner nodes</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">base</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="n">_tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">_tree</span><span class="p">(</span><span class="n">base</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// init leaf nodes</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">_tree</span><span class="p">[</span><span class="n">base</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// init inner nodes</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">base</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="n">_tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">i</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="c1">// only support const version</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">_n</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"index out of range"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">_tree</span><span class="p">[</span><span class="n">base</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed setting update</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">_n</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"set index out of bounds"</span><span class="p">);</span>

        <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span> <span class="o">+=</span> <span class="n">base</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

        <span class="c1">// update form bottom to top idx [2, x)</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">idx</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed incremental update</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">_op</span><span class="p">(</span><span class="k">operator</span><span class="p">[](</span><span class="n">idx</span><span class="p">),</span> <span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed range query [p, r]</span>
    <span class="n">T</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// special scene should return identity</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">_n</span><span class="p">)</span> <span class="k">return</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="c1">// void Out-of-bounds access</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="n">T</span> <span class="n">res_left</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">res_right</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">+=</span> <span class="n">base</span><span class="p">(),</span> <span class="n">r</span> <span class="o">+=</span> <span class="n">base</span><span class="p">();</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// p is right child node</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">res_left</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">res_left</span><span class="p">,</span> <span class="n">_tree</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]);</span>
            <span class="c1">// r is left child node</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="n">res_right</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">],</span> <span class="n">res_right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">_op</span><span class="p">(</span><span class="n">res_left</span><span class="p">,</span> <span class="n">res_right</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">int</span> <span class="n">base</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_tree</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_n</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">base</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">base</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="n">base</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">left</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">right</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">int</span> <span class="n">_n</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_tree</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="递归线段树不推荐">递归线段树（不推荐）</h2>
<p>除了效率低点，其它跟迭代线段树没有任何区别</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Copyright (c) 2025 pk. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a MIT license</span>
<span class="c1">// if you like this code, don't delete this, thanks.</span>


<span class="c1">// identity variable template(C++14)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// std::plus partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::multiplies partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// std::bit_and partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_and</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">~</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_or partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_or</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_xor partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_xor</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// maximum partial variable template specialization</span>
<span class="c1">// std::maximum is function template, not types of functors</span>
<span class="c1">// float type should use lowest() instead of min()</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Max</span>  <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// template&lt;typename T&gt; constexpr auto identity_value&lt;Max , T&gt; = std::is_floating_point_v&lt;T&gt; ? std::numeric_limits&lt;T&gt;::lowest() : std::numeric_limits&lt;T&gt;::min();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Max</span> <span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">();</span>

<span class="c1">// minimum partial variable template specialization</span>
<span class="c1">// std::min is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Min</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Min</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

<span class="c1">// gcd partial variable template specialization</span>
<span class="c1">// std::gcd(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Gcd</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">gcd</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Gcd</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// lcm partial variable template specialization</span>
<span class="c1">// std::lcm(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Lcm</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lcm</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Lcm</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">init_value</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">:</span> <span class="n">_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">init_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="o">:</span> <span class="n">_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    
    <span class="c1">// only support const version</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"index out of range"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"index out of range"</span><span class="p">);</span>
        <span class="c1">// 线段树 1 号节点，维护整个数组信息</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"index out of range"</span><span class="p">);</span>
        <span class="c1">// 线段树 1 号节点，维护整个数组信息</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">T</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="c1">// special scene should return identity</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="c1">// void Out-of-bounds access</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nf">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">left</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">right</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_tree</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">//idx 线段树节点下标, [p, r] 维护区间, x 更新位置 0-indexed, val 增量/修改后的值</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 到达叶节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_set</span> <span class="o">?</span> <span class="n">val</span> <span class="o">:</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新位置与左半维护区间有交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">is_set</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 更新位置与右半维护区间有交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">is_set</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 回溯</span>
        <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="c1">//idx 线段树节点下标, [p, r] 维护区间, [x, y]查询区间 0-indexed</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">T</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// 维护区间在查询区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间与左半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间与右半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_tree</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="区间修改--区间查询">区间修改 + 区间查询</h1>
<h2 id="递归线段树推荐to-check">递归线段树（推荐）（to check）</h2>

<p>为了支持快速区间修改，线短树引入 <strong>懒标记</strong></p>

<ul>
  <li>懒标记：区间修改时，只是进行简单标记，并不将修改实际生效到每个元素；在查询前，会将标记下沉，使得修改生效。</li>
  <li>不使用懒标记的区间修改时间复杂度为线性，使用后可达到 $O(log(n))$</li>
</ul>

<p>支持区间和、区间最大/小值</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Copyright (c) 2025 pk. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a MIT license</span>
<span class="c1">// if you like this code, don't delete this, thanks.</span>


<span class="c1">// identity variable template(C++14)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// std::plus partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::multiplies partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// std::bit_and partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_and</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">~</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_or partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_or</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// std::bit_xor partial variable template specialization</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_xor</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// maximum partial variable template specialization</span>
<span class="c1">// std::maximum is function template, not types of functors</span>
<span class="c1">// float type should use lowest() instead of min()</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Max</span>  <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// template&lt;typename T&gt; constexpr auto identity_value&lt;Max , T&gt; = std::is_floating_point_v&lt;T&gt; ? std::numeric_limits&lt;T&gt;::lowest() : std::numeric_limits&lt;T&gt;::min();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Max</span> <span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">();</span>

<span class="c1">// minimum partial variable template specialization</span>
<span class="c1">// std::min is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Min</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Min</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

<span class="c1">// gcd partial variable template specialization</span>
<span class="c1">// std::gcd(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Gcd</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">gcd</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Gcd</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// lcm partial variable template specialization</span>
<span class="c1">// std::lcm(c++17) is function template, not types of functors</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">Lcm</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lcm</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Lcm</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Magic</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">merge</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Magic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">merge</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">len</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Magic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">merge</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Magic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">bit_xor</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">merge</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">val</span> <span class="o">:</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">init_value</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_tree</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_tag</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">init_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_tree</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_tag</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">_op</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 0-indexed</span>
    <span class="n">T</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">left</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">right</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">mid</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_tree</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 懒标记下沉, idx 线段树节点下标 [p, r] 维护区间 0-indexed</span>
    <span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="c1">// 左维护区间下沉</span>
        <span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">Magic</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">merge</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">_tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="c1">// 右维护区间下沉</span>
        <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">Magic</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">merge</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">r</span> <span class="o">-</span> <span class="n">q</span><span class="p">));</span>
        <span class="n">_tag</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//idx 线段树节点下标 [p, r] 维护区间, [x, y] 更新区间 0-indexed z 增量</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在更新区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Magic</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">merge</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和左半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和右半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 回溯</span>
        <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">_tree</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">_tree</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在查询区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">_tree</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">identity_value</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和左半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和右半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_op</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_tree</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_tag</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>为什么在 <code class="language-plaintext highlighter-rouge">update</code> 的时候也需要懒标记下沉？？</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">update</code> 回溯的时候会更新区间信息。为什么回溯的时候需要 <code class="language-plaintext highlighter-rouge">update</code> ？？？</li>
  <li>没有下沉会导致左右子树的信息缺失，最终导致回溯到父节点信息缺失。</li>
</ul>

<h2 id="迭代线段树不推荐">迭代线段树（不推荐）</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h1 id="练习">练习</h1>

<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii">LeetCode 2407. 最长递增子序列 II</a></p>

<p><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a></p>

<p><a href="https://leetcode.cn/problems/handling-sum-queries-after-update/">2569. 更新数组后处理求和查询</a></p>

<h1 id="封装">封装</h1>

<p>0 indexed</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Sequence</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Tp</span><span class="p">&gt;,</span>
    <span class="k">typename</span> <span class="n">Calculate</span> <span class="o">=</span> <span class="n">plus</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">Accumulate</span> <span class="o">=</span> <span class="n">Accumulate</span><span class="o">&lt;</span><span class="n">Calculate</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">reference</span> <span class="n">reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">const_reference</span> <span class="n">const_reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Sequence</span> <span class="n">container_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Calculate</span> <span class="n">value_calculate</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="k">const</span> <span class="n">value_type</span> <span class="n">init_val</span><span class="p">;</span>
    <span class="c1">//懒标记</span>
    <span class="n">container_type</span> <span class="n">tag</span><span class="p">;</span>
    <span class="c1">//线段树</span>
    <span class="n">container_type</span> <span class="n">seg</span><span class="p">;</span>
    <span class="n">Calculate</span> <span class="n">cal</span><span class="p">;</span>
    <span class="n">Accumulate</span> <span class="n">acc</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">seg</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="n">Sequence</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">seg</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span>
        <span class="n">seg</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">value_type</span> <span class="nf">query</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">left</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">right</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">mid</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// idx 线段树节点下标</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="c1">// 懒标记下沉, idx 线段树节点下标 [p, r] 维护区间 0-indexed</span>
    <span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">init_val</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="c1">// 左维护区间下沉</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">acc</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]));</span>
        <span class="n">tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="c1">// 右维护区间下沉</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">acc</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]));</span>
        <span class="n">tag</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//idx 线段树节点下标 [p, r] 维护区间, [x, y] 更新区间 0-indexed z 增量</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">y</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在更新区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">acc</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
            <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和左半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和右半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 回溯</span>
        <span class="n">update</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">value_type</span> <span class="nf">query</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在查询区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="n">size_type</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">value_type</span> <span class="n">res</span> <span class="o">=</span> <span class="n">init_val</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和左半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和右半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h2 id="default">default</h2>

<p>默认累积函数：适用于 min、max</p>

<p>bit_and、bit_or ？？？？</p>

<p>懒标记：</p>

<ul>
  <li>max(x, y, z) = max(x, max(y, z))</li>
  <li>x &amp; y &amp; z = x &amp; (y &amp; z)</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>x</td>
          <td>y</td>
          <td>z = x</td>
          <td>(y</td>
          <td>z)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Accumulate</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="plus">plus</h2>

<p>懒标记 x + y + z = x + (y + z)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Accumulate</span><span class="o">&lt;</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">Tp</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="bit_xor">bit_xor</h2>

<p>懒标记 x ^ y ^ z = x ^ (y ^ z)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Accumulate</span><span class="o">&lt;</span><span class="n">bit_xor</span><span class="o">&lt;</span><span class="n">Tp</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">val</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="multiplies">multiplies</h2>

<p>懒标记 x * y * z = x * (y * z)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Accumulate</span><span class="o">&lt;</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="n">Tp</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tp</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">//return qpow(val, x);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="第三次封装">第三次封装</h1>

<h2 id="区间更新">区间更新</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Max</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Min</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Sequence</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Tp</span><span class="p">&gt;,</span>
    <span class="k">typename</span> <span class="n">Calculate</span> <span class="o">=</span> <span class="n">Max</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">reference</span> <span class="n">reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">const_reference</span> <span class="n">const_reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Sequence</span><span class="o">::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Sequence</span> <span class="n">container_type</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="k">const</span> <span class="n">value_type</span> <span class="n">init_val</span><span class="p">;</span>
    <span class="c1">//懒标记</span>
    <span class="n">container_type</span> <span class="n">tag</span><span class="p">;</span>
    <span class="c1">//线段树</span>
    <span class="n">container_type</span> <span class="n">seg</span><span class="p">;</span>
    <span class="n">Calculate</span> <span class="n">cal</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">seg</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="k">const</span> <span class="n">Sequence</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">seg</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="nf">SegmentTree</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">init_val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">tag</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span>
        <span class="n">seg</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">value_type</span> <span class="nf">query</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">left</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">right</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">static</span> <span class="n">size_type</span> <span class="nf">mid</span><span class="p">(</span><span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// idx 线段树节点下标</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="c1">// 懒标记下沉, idx 线段树节点下标 [p, r] 维护区间 0-indexed</span>
    <span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">init_val</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="c1">// 左维护区间下沉</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">update_seg</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="n">tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">update_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="c1">// 右维护区间下沉</span>
        <span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">update_seg</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">tag</span><span class="p">[</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">update_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

        <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//idx 线段树节点下标 [p, r] 维护区间, [x, y] 更新区间 0-indexed z 增量</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">y</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在更新区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_seg</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
            <span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_tag</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和左半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新区间和右半维护区间存在交集</span>
            <span class="n">update</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 回溯</span>
        <span class="n">update</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">value_type</span> <span class="nf">query</span><span class="p">(</span><span class="n">size_type</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">x</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 节点维护区间在查询区间范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">seg</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

        <span class="c1">// 懒标记下沉</span>
        <span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

        <span class="n">size_type</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">value_type</span> <span class="n">res</span> <span class="o">=</span> <span class="n">init_val</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和左半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">left</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 查询区间和右半维护区间存在交集</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">cal</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">query</span><span class="p">(</span><span class="n">right</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kr">inline</span> <span class="n">Tp</span> <span class="nf">update_tag</span><span class="p">(</span><span class="n">const_reference</span> <span class="n">old</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">nw</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 累积类型: sum, bit_xor, bit_and, bit_or</span>
        <span class="c1">// return cal(old, nw);</span>
        <span class="c1">// 设置类型: max, min</span>
        <span class="k">return</span> <span class="n">nw</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kr">inline</span> <span class="n">Tp</span> <span class="nf">update_seg</span><span class="p">(</span><span class="n">const_reference</span> <span class="n">old</span><span class="p">,</span> <span class="n">const_reference</span> <span class="n">val</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// sum</span>
        <span class="c1">// return cal(old, (r - p + 1) * val);</span>
        <span class="c1">// bit_xor</span>
        <span class="c1">// return cal(old, ((r - p + 1) &amp; 1) ? val, 0);</span>
        <span class="c1">// bit_and, bit_or</span>
        <span class="c1">// 设置类型: max, min</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>pk</name></author><category term="计算机" /><category term="数据结构与算法" /><category term="树" /><category term="rmq" /><summary type="html"><![CDATA[xxxxxxxxxxxxxxxxxx]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/69.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/69.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">弗洛伊德（Floyd）</title><link href="https://xdevil.top/2025/08/21/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd.html" rel="alternate" type="text/html" title="弗洛伊德（Floyd）" /><published>2025-08-21T00:00:00+00:00</published><updated>2025-08-21T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/21/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%EF%BC%88Floyd%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/2025/08/21/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd.html"><![CDATA[<p>Floyd 算法（也称为 Floyd-Warshall 算法）是一种非常经典且优雅的<strong>动态规划</strong>算法，用于解决<strong>图中所有顶点对之间的最短路径问题</strong>。它的核心思想是通过逐步扩展允许经过的中间顶点集，来动态地更新任意两点间的最短距离。</p>

<h1 id="动态规划原理">动态规划原理</h1>

<p>算法使用一个三重循环来不断更新一个距离矩阵 <code class="language-plaintext highlighter-rouge">dist</code>。</p>
<h2 id="状态定义">状态定义</h2>
<p><code class="language-plaintext highlighter-rouge">dist[k][i][j]</code>：表示从顶点 <code class="language-plaintext highlighter-rouge">i</code> 到顶点 <code class="language-plaintext highlighter-rouge">j</code> 的路径，经过的中间点集 <code class="language-plaintext highlighter-rouge">{0, 1, 2, ..., k-1}</code> （不包括起点和终点）时的最短路径长度。</p>

<h2 id="状态转移">状态转移</h2>
<p>对于每一个中间顶点 <code class="language-plaintext highlighter-rouge">k</code>，我们考虑是否通过这个新顶点 <code class="language-plaintext highlighter-rouge">k</code> 能让路径 <code class="language-plaintext highlighter-rouge">i -&gt; j</code> 变得更短 <code class="language-plaintext highlighter-rouge">dist[k][i][j] = min(dist[k-1][i][j], dist[k-1][i][k] + dist[k-1][k][j])</code></p>
<ul>
  <li><strong>不经过 <code class="language-plaintext highlighter-rouge">k</code></strong>：保持上一阶段的最短路径 <code class="language-plaintext highlighter-rouge">dist[k-1][i][j]</code>。</li>
  <li><strong>经过 <code class="language-plaintext highlighter-rouge">k</code></strong>：将路径分解为 <code class="language-plaintext highlighter-rouge">i -&gt; k</code> 和 <code class="language-plaintext highlighter-rouge">k -&gt; j</code> 两段。这两段路径在上一阶段 (<code class="language-plaintext highlighter-rouge">k-1</code>) 已经被计算过，并且它们只使用了 <code class="language-plaintext highlighter-rouge">{0, 1, ..., k-1}</code> 中的顶点作为中间点。</li>
</ul>

<blockquote>
  <p>注意，为啥不是 <code class="language-plaintext highlighter-rouge">dist[k][i][k] + dist[k][k][j]</code> 呢？
-<code class="language-plaintext highlighter-rouge">i -&gt; k</code> 经过点集 <code class="language-plaintext highlighter-rouge">{0, 1, 2, ..., k-1}</code> 的最短路径 和 经过点集 <code class="language-plaintext highlighter-rouge">{0, 1, 2, ..., k-1, k}</code> 的最短路径有啥区别呢，没区别！</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">dist[k][i][k] = dist[k - 1][i][k]</code> , <code class="language-plaintext highlighter-rouge">dist[k][k][j] = dist[k - 1][k][j]</code></li>
  </ul>
</blockquote>

<h2 id="优化空间复杂度">优化空间复杂度</h2>
<p>由于 <code class="language-plaintext highlighter-rouge">dist[k][i][j]</code> 只依赖于 <code class="language-plaintext highlighter-rouge">dist[k-1][...]</code>，我们可以使用一个二维数组 <code class="language-plaintext highlighter-rouge">dist[i][j]</code>，通过<strong>就地更新</strong>（in-place）来节省空间，将三维DP表“压扁”成二维。这就是我们通常见到的形式。</p>

<p>最终的状态转移方程变为：<code class="language-plaintext highlighter-rouge">if (dist[i][k] + dist[k][j] &lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; }</code></p>

<blockquote>
  <p>注意: 此处的 <code class="language-plaintext highlighter-rouge">dist[i][k]</code> 和 <code class="language-plaintext highlighter-rouge">dist[k][j]</code> 不一定都是第 <code class="language-plaintext highlighter-rouge">k - 1</code> 阶段的，但不影响计算及过（详见状态转移部分的注意）</p>
</blockquote>

<h2 id="复杂度">复杂度</h2>
<p><strong>时间复杂度</strong>：<code class="language-plaintext highlighter-rouge">O(|V|³)</code>。三重循环，非常直观。
<strong>空间复杂度</strong>：<code class="language-plaintext highlighter-rouge">O(|V|²)</code>。只需要存储一个距离矩阵。</p>

<h1 id="算法步骤">算法步骤</h1>

<p><strong>初始化</strong>：</p>
<ul>
  <li>创建一个 <code class="language-plaintext highlighter-rouge">n x n</code> 的矩阵 <code class="language-plaintext highlighter-rouge">dist</code>（<code class="language-plaintext highlighter-rouge">n</code> 为顶点数）</li>
  <li>如果存在边 <code class="language-plaintext highlighter-rouge">i -&gt; j</code>，则 <code class="language-plaintext highlighter-rouge">dist[i][j]</code> 初始化为该边的权重</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">i == j</code>，则 <code class="language-plaintext highlighter-rouge">dist[i][j] = 0</code>（自身到自身的距离为0）</li>
  <li>如果不存在边 <code class="language-plaintext highlighter-rouge">i -&gt; j</code>，则 <code class="language-plaintext highlighter-rouge">dist[i][j]</code> 初始化为一个<strong>极大值</strong>（例如 <code class="language-plaintext highlighter-rouge">Infinity</code>），代表无穷大/不可达</li>
</ul>

<p><strong>三重循环更新</strong>：</p>
<ul>
  <li>最外层循环：中间顶点 <code class="language-plaintext highlighter-rouge">k</code>，从 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">n-1</code></li>
  <li>内层两层循环：起点 <code class="language-plaintext highlighter-rouge">i</code> 和终点 <code class="language-plaintext highlighter-rouge">j</code>，都从 <code class="language-plaintext highlighter-rouge">0</code> 到 <code class="language-plaintext highlighter-rouge">n-1</code></li>
  <li>对于每一对 <code class="language-plaintext highlighter-rouge">(i, j)</code>，检查 <code class="language-plaintext highlighter-rouge">i -&gt; k -&gt; j</code> 这条路径是否比当前已知的 <code class="language-plaintext highlighter-rouge">i -&gt; j</code> 路径更短。如果是，则更新 <code class="language-plaintext highlighter-rouge">dist[i][j]</code></li>
</ul>

<p><strong>结果</strong>： 算法结束后，<code class="language-plaintext highlighter-rouge">dist[i][j]</code> 中存储的就是顶点 <code class="language-plaintext highlighter-rouge">i</code> 到顶点 <code class="language-plaintext highlighter-rouge">j</code> 的<strong>最短路径距离</strong>。</p>

<h1 id="应用场景">应用场景</h1>
<p>可以处理<strong>有向图</strong>和<strong>无向图</strong>。</p>

<p>可以处理<strong>负权边</strong>。</p>

<p><strong>不能处理包含负权回路（Negative Cycle）的图</strong>。因为负权回路可以让路径长度无限减小，不存在最短路径。</p>

<h1 id="代码">代码</h1>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//初始化</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">));</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//w[i][j] 为权重</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//计算最短距离</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//默认值设为 INT_MAX / 2 防止这里溢出</span>
            <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="重构最短路径">重构最短路径??????????</h1>

<p>如果需要知道具体路径而不仅仅是距离，可以维护一个 <code class="language-plaintext highlighter-rouge">next</code> 矩阵。</p>
<ol>
  <li><strong>初始化 <code class="language-plaintext highlighter-rouge">next</code> 矩阵</strong>：
    <ul>
      <li>如果 <code class="language-plaintext highlighter-rouge">i</code> 和 <code class="language-plaintext highlighter-rouge">j</code> 之间有边，则 <code class="language-plaintext highlighter-rouge">next[i][j] = j</code>。</li>
      <li>否则，<code class="language-plaintext highlighter-rouge">next[i][j] = None</code>。</li>
    </ul>
  </li>
  <li><strong>在更新距离时同步更新 <code class="language-plaintext highlighter-rouge">next</code> 矩阵</strong>：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>  <span class="c1"># 路径走向：i -&gt; ... -&gt; k -&gt; ... -&gt; j
</span></code></pre></div>    </div>
  </li>
  <li><strong>重构路径</strong>：
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>devil</name></author><category term="图论" /><summary type="html"><![CDATA[多源最短路径、动态规划]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/68.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/68.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">格雷码（Gray Code）</title><link href="https://xdevil.top/2025/08/20/%E6%A0%BC%E9%9B%B7%E7%A0%81-Gray-Code.html" rel="alternate" type="text/html" title="格雷码（Gray Code）" /><published>2025-08-20T00:00:00+00:00</published><updated>2025-08-20T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/20/%E6%A0%BC%E9%9B%B7%E7%A0%81%EF%BC%88Gray%20Code%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/2025/08/20/%E6%A0%BC%E9%9B%B7%E7%A0%81-Gray-Code.html"><![CDATA[<h1 id="格雷码">格雷码</h1>

<p>格雷码，又称<strong>循环码</strong>或<strong>反射码</strong>，是一种<strong>二进制数字系统</strong>。
在这个系统中，两个连续数值的二进制表示<strong>仅有一位不同</strong>。这种特性使得它在数字电路、错误校正和通信等领域非常有用。</p>

<p>关键特性：</p>
<ul>
  <li><strong>单位距离性</strong>：相邻两个码字之间只有一位二进制数不同。</li>
  <li><strong>循环性</strong>：最后一个码字与第一个码字之间也仅有一位不同。</li>
</ul>

<p>为什么需要格雷码：在传统的二进制计数中，数字的递增可能导致多位同时变化（例如，从 <code class="language-plaintext highlighter-rouge">0111</code>（7）到 <code class="language-plaintext highlighter-rouge">1000</code>（8）），这可能在硬件中产生<strong>竞争冒险</strong>或<strong>瞬时错误</strong>（glitches）。格雷码避免了多位同时变化，从而减少了这类问题。</p>
<ul>
  <li><strong>旋转编码器</strong>：用于确定机械位置，避免边界值读取错误。</li>
  <li><strong>数字通信</strong>：减少传输错误。</li>
  <li><strong>卡诺图</strong>：用于逻辑最小化。</li>
  <li><strong>遗传算法</strong>：表示基因序列。</li>
  <li>在硬件和通信中广泛应用，避免多位跳变带来的错误。</li>
  <li>与二进制转换方便，通过异或运算即可实现。</li>
</ul>

<h1 id="格雷码生成">格雷码生成</h1>

<p>有多种方法可以生成格雷码，这里介绍两种常见方法。</p>
<h2 id="递归反射法">递归反射法</h2>
<p>步骤：</p>
<ul>
  <li>从 <code class="language-plaintext highlighter-rouge">n = 1</code> 开始，基础格雷码是 <code class="language-plaintext highlighter-rouge">[0, 1]</code>。</li>
  <li>对于 <code class="language-plaintext highlighter-rouge">n+1</code> 位格雷码：
    <ul>
      <li>将 <code class="language-plaintext highlighter-rouge">n</code> 位格雷码的每个元素前加 <code class="language-plaintext highlighter-rouge">0</code>（称为<strong>反射</strong>）。</li>
      <li>将 <code class="language-plaintext highlighter-rouge">n</code> 位格雷码<strong>逆序</strong>，每个元素前加 <code class="language-plaintext highlighter-rouge">1</code>。</li>
      <li>将这两个列表拼接起来，得到 <code class="language-plaintext highlighter-rouge">n+1</code> 位格雷码。</li>
    </ul>
  </li>
</ul>

<p>生成 2 位格雷码：</p>
<ul>
  <li>1 位： <code class="language-plaintext highlighter-rouge">[0, 1]</code></li>
  <li>2 位：</li>
  <li>前加 0：<code class="language-plaintext highlighter-rouge">[00, 01]</code></li>
  <li>逆序前加 1：<code class="language-plaintext highlighter-rouge">[11, 10]</code></li>
  <li>拼接：<code class="language-plaintext highlighter-rouge">[00, 01, 11, 10]</code></li>
</ul>

<p>生成 3 位格雷码：</p>
<ul>
  <li>基于 2 位 <code class="language-plaintext highlighter-rouge">[00, 01, 11, 10]</code></li>
  <li>前加 0：<code class="language-plaintext highlighter-rouge">[000, 001, 011, 010]</code></li>
  <li>逆序前加 1：<code class="language-plaintext highlighter-rouge">[110, 111, 101, 100]</code></li>
  <li>拼接：<code class="language-plaintext highlighter-rouge">[000, 001, 011, 010, 110, 111, 101, 100]</code></li>
</ul>

<h2 id="方法二公式法">方法二：公式法</h2>
<p>第 $i$ 个格雷码可通过公式：$G_i = i \oplus (i » 1)$</p>

<p>示例（生成 3 位格雷码，i 从 0 到 7）：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">十进制 $i$</th>
      <th style="text-align: center">二进制 $i$</th>
      <th style="text-align: center">$i » 1$</th>
      <th style="text-align: center">$i \oplus (i » 1)$</th>
      <th style="text-align: center">格雷码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">000</td>
      <td style="text-align: center">000</td>
      <td style="text-align: center">000 $\oplus$ 000 = 000</td>
      <td style="text-align: center">000</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">001</td>
      <td style="text-align: center">000</td>
      <td style="text-align: center">001 $\oplus$ 000 = 001</td>
      <td style="text-align: center">001</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">010</td>
      <td style="text-align: center">001</td>
      <td style="text-align: center">010 $\oplus$ 001 = 011</td>
      <td style="text-align: center">011</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">011</td>
      <td style="text-align: center">001</td>
      <td style="text-align: center">011 $\oplus$ 001 = 010</td>
      <td style="text-align: center">010</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">100</td>
      <td style="text-align: center">010</td>
      <td style="text-align: center">100 $\oplus$ 010 = 110</td>
      <td style="text-align: center">110</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">101</td>
      <td style="text-align: center">010</td>
      <td style="text-align: center">101 $\oplus$ 010 = 111</td>
      <td style="text-align: center">111</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">110</td>
      <td style="text-align: center">011</td>
      <td style="text-align: center">110 $\oplus$ 011 = 101</td>
      <td style="text-align: center">101</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">111</td>
      <td style="text-align: center">011</td>
      <td style="text-align: center">111 $\oplus$ 011 = 100</td>
      <td style="text-align: center">100</td>
    </tr>
  </tbody>
</table>

<p>二进制转格雷码（第 i 个格雷码是什么）：</p>
<ul>
  <li>最高位不变。</li>
  <li>从左到右，每一位与它左边的一位进行异或（XOR）。</li>
  <li>公式：$G_k = B_k \oplus B_{k-1}（其中 B_{-1} = 0$。</li>
</ul>

<p><strong>示例（二进制 <code class="language-plaintext highlighter-rouge">1101</code> 转格雷码）</strong>：</p>
<ul>
  <li>最高位：1</li>
  <li>1 ⊕ 1 = 0</li>
  <li>1 ⊕ 0 = 1</li>
  <li>0 ⊕ 1 = 1</li>
  <li>格雷码：<code class="language-plaintext highlighter-rouge">1011</code></li>
</ul>

<p>格雷码转二进制（格雷码的索引是什么）：</p>
<ul>
  <li>最高位不变。</li>
  <li>从左到右，每一位与已计算的二进制位进行异或。</li>
  <li>公式：$B_k = G_k \oplus B_{k-1}$</li>
</ul>

<p><strong>示例（格雷码 <code class="language-plaintext highlighter-rouge">1011</code> 转二进制）</strong>：</p>
<ul>
  <li>最高位：1</li>
  <li>0 ⊕ 1 = 1</li>
  <li>1 ⊕ 1 = 0</li>
  <li>1 ⊕ 0 = 1</li>
  <li>二进制：<code class="language-plaintext highlighter-rouge">1101</code></li>
</ul>]]></content><author><name>devil</name></author><category term="数论" /><summary type="html"><![CDATA[格雷码、格雷码生成]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/66.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/66.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">隔板法（Stars and Bars）</title><link href="https://xdevil.top/2025/08/20/%E9%9A%94%E6%9D%BF%E6%B3%95-Stars-and-Bars.html" rel="alternate" type="text/html" title="隔板法（Stars and Bars）" /><published>2025-08-20T00:00:00+00:00</published><updated>2025-08-20T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/20/%E9%9A%94%E6%9D%BF%E6%B3%95%EF%BC%88Stars%20and%20Bars%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/2025/08/20/%E9%9A%94%E6%9D%BF%E6%B3%95-Stars-and-Bars.html"><![CDATA[<p>隔板法（Stars and Bars）是组合数学中一种用于计数分配问题的方法，特别适用于将<strong>不可区分的物品</strong>分配给<strong>可区分的容器</strong>的问题。其核心思想是通过插入“隔板”来划分物品，从而将问题转化为组合数的计算。</p>

<h1 id="标准隔板法问题">标准隔板法问题</h1>
<p>问题描述：将 $n$ 个相同的物品分配给 $k$ 个不同的组，每组至少分到 1 个物品。</p>

<p>解法：</p>
<ul>
  <li>将 $n$ 个物品排成一行，形成 $n-1$ 个空隙</li>
  <li>插入 $k-1$ 个隔板，将物品分成 $k$ 组（隔板不可重合，且不能放在两端）</li>
  <li>分配方案数等于在 $n-1$ 个空隙中选择 $k-1$ 个放置隔板，即：$C_{n-1}^{k-1}$</li>
</ul>

<h1 id="允许组为空即每组可以分到-0-个">允许组为空（即每组可以分到 0 个）</h1>
<p>问题描述：将 $n$ 个相同的物品分配给 $k$ 个不同的组，允许有空组。</p>

<p>解法：</p>
<ul>
  <li>先借 $k$ 个物品，每人先分 1 个（保证非负），问题转化为：分配 $n+k$ 个物品，每组至少 1 个。</li>
  <li>方案数为： $C_{n+k-1}^{k-1}$</li>
</ul>

<h1 id="每组至少分到-t-个非-1-个">每组至少分到 $t$ 个（非 1 个）</h1>
<p>问题描述：将 $n$ 个相同的物品分配给 $k$ 个组，每组至少分到 $t$ 个。<br />
解法：</p>
<ul>
  <li>先给每组分配 $t-1$ 个，剩余 $n - k(t-1)$ 个物品。</li>
  <li>问题转化为：将剩余物品分配，每组至少 1 个（标准隔板法）。</li>
  <li>方案数为： $C_{n - k(t-1) - 1}^{k-1}$</li>
</ul>

<h1 id="其他约束如上下限">其他约束（如上下限）</h1>
<p>若每组有不同约束（如 $a_i \leq x_i \leq b_i$），通常通过<strong>容斥原理</strong>或<strong>生成函数</strong>结合隔板法求解??????????????</p>

<p>隔板法等价于求方程 $x_1 + x_2 + \cdots + x_k = n$ 的非负整数解（允许空组）或正整数解（每组至少1个）。</p>]]></content><author><name>devil</name></author><category term="排列组合" /><summary type="html"><![CDATA[隔板法]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/67.png" /><media:content medium="image" url="https://xdevil.top/assets/image/67.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">斯特林数（Stirling Numbers）</title><link href="https://xdevil.top/2025/08/19/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0-Stirling-Numbers.html" rel="alternate" type="text/html" title="斯特林数（Stirling Numbers）" /><published>2025-08-19T00:00:00+00:00</published><updated>2025-08-19T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/19/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%EF%BC%88Stirling%20Numbers%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/2025/08/19/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0-Stirling-Numbers.html"><![CDATA[<h1 id="概述">概述</h1>

<p>斯特林数是组合数学中的一类重要整数，因数学家詹姆斯·斯特林（James Stirling）而得名
它们用于描述集合的划分和排列方式，主要分为 <strong>第一类斯特林数</strong> 和 <strong>第二类斯特林数</strong> 两种</p>
<ul>
  <li><strong>第二类</strong>：划分集合（集合内部无序）。</li>
  <li><strong>第一类</strong>：排列成循环（循环内部旋转等价，但不同循环之间无序）</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$n$</th>
      <th style="text-align: center">$k$</th>
      <th style="text-align: center">$S(n,k)$（第二类）</th>
      <th style="text-align: center">$s(n,k)$（无符号第一类）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">11</td>
    </tr>
  </tbody>
</table>

<h1 id="第二类斯特林数stirling-numbers-of-the-second-kind">第二类斯特林数（Stirling numbers of the second kind）</h1>

<h2 id="定义">定义</h2>
<p>表示将 $n$ 个 <strong>不同元素</strong> 划分成 $k$ 个 <strong>非空无标号集合（盒子不可区分）</strong> 的方案数，记作 $S(n, k)$</p>

<p>示例：将3个元素 <code class="language-plaintext highlighter-rouge">[a,b,c]</code> 划分成 2 个非空集合，$S(3, 2) = 3$</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[a,b]</code>, <code class="language-plaintext highlighter-rouge">[c]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[a,c]</code>, <code class="language-plaintext highlighter-rouge">[b]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[b,c]</code>, <code class="language-plaintext highlighter-rouge">[a]</code></li>
</ul>

<h2 id="递推公式">递推公式</h2>
<p>\(S(n, k) = S(n - 1, k - 1) + k \cdot S(n - 1, k)\)</p>

<p>边界条件：</p>
<ul>
  <li>$S(n, 0) = 0, (n \geq 1)$</li>
  <li>$S(n, 1) = 1$</li>
  <li>$S(n, n) = 1$</li>
  <li>$S(n, k) = 0,(k \gt n)$</li>
</ul>

<p>递推公式含义：对于第 $n$ 个数</p>
<ul>
  <li>将其单独分配到一个集合中时，有 $S(n - 1, k - 1)$ 种划分方式</li>
  <li>将其与其他原元素分配到一个集合时，有 $k \cdot S(n - 1, k)$ 种划分方式</li>
</ul>

<h2 id="通项公式">通项公式??????????????</h2>

\[S(n, k) = \frac{1}{k!} \sum_{i=0}^{k} (-1)^i \binom{k}{i} (k-i)^n\]

<h2 id="应用">应用</h2>
<p>集合划分计数（如球放入不可区分盒子且非空）。</p>

<p>与贝尔数相关。</p>

<h1 id="第一类斯特林数stirling-numbers-of-the-first-kind">第一类斯特林数（Stirling numbers of the first kind）</h1>
<h2 id="定义-1">定义</h2>
<p>表示将 $n$ 个 <strong>不同元素</strong> 排成 $k$ 个 <strong>循环排列</strong>（圆排列）的方案数，记作 s(n, k)</p>

<p>有符号和无符号两种，通常无符号更常用</p>
<ul>
  <li><strong>无符号第一类斯特林数</strong>（常用）：记作 $c(n, k)$ 表示循环排列数</li>
  <li><strong>有符号第一类斯特林数</strong>：包含正负号，与下降幂相关??????????</li>
</ul>

<p>例子：将3个元素排成2个循环排列方案 $s(3,2) = 3$（无符号）:</p>
<ul>
  <li>(a)(b c)</li>
  <li>(b)(a c)</li>
  <li>(c)(a b)</li>
</ul>

<h2 id="递推公式-1">递推公式</h2>
<p>\(s(n, k) = s(n - 1, k - 1) + (n - 1) \cdot s(n - 1, k)\)</p>

<p>边界条件：</p>
<ul>
  <li>$s(n, 0) = 0, (n \geq 1)$</li>
  <li>$s(n, 1) = (n - 1)!$</li>
  <li>$s(n, n) = 1$</li>
</ul>

<p>递推公式理解：对于第 $n$ 个元素来说</p>
<ul>
  <li>独自成环时，有 $s(n - 1, k - 1)$ 种方案</li>
  <li>非独自成环时，将其分别放在 $n - 1$ 个元素旁边，有 $(n - 1) \cdot s(n - 1, k)$ 种方案</li>
</ul>

<h2 id="应用-1">应用</h2>
<p>循环排列计数（如轮换分解）</p>

<p>多项式系数（上升幂/下降幂展开）</p>

<h1 id="生成函数">生成函数??????????</h1>
<p>第二类斯特林数的生成函数：
\(\sum_{n=k}^{\infty} S(n,k) \frac{x^n}{n!} = \frac{(e^x - 1)^k}{k!}\)</p>

<p>第一类斯特林数的生成函数（上升阶乘幂）：
\(x(x+1)(x+2)\cdots(x+n-1) = \sum_{k=0}^{n} s(n,k) x^k\)</p>]]></content><author><name>devil</name></author><category term="排列组合" /><summary type="html"><![CDATA[第一类斯特林数、第二类斯特林数]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/64.png" /><media:content medium="image" url="https://xdevil.top/assets/image/64.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">贝尔数（Bell Numbers）</title><link href="https://xdevil.top/2025/08/19/%E8%B4%9D%E5%B0%94%E6%95%B0-Bell-Numbers.html" rel="alternate" type="text/html" title="贝尔数（Bell Numbers）" /><published>2025-08-19T00:00:00+00:00</published><updated>2025-08-19T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/19/%E8%B4%9D%E5%B0%94%E6%95%B0%EF%BC%88Bell%20Numbers%EF%BC%89</id><content type="html" xml:base="https://xdevil.top/2025/08/19/%E8%B4%9D%E5%B0%94%E6%95%B0-Bell-Numbers.html"><![CDATA[<h1 id="贝尔数">贝尔数</h1>
<p>贝尔数($Bell \ numbers$)是组合数学中一个非常重要且优美的数列，它以数学家埃里克·坦普尔·贝尔（Eric Temple Bell）的名字命名。</p>

<p>记为 $B_n$，它表示的是 <strong>一个有 $n$ 个元素的集合，能够划分成非空子集的全部方法的数量</strong></p>

<p>$B_3 = 5$ 其划分方案如下：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2]</code>, <code class="language-plaintext highlighter-rouge">[3]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2, 3]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[2]</code>, <code class="language-plaintext highlighter-rouge">[1, 3]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[3]</code>, <code class="language-plaintext highlighter-rouge">[1, 2]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1, 2, 3]</code></li>
</ul>

<p>贝尔数确实有一个非常经典且实用的递推公式，它依赖于另一个重要的概念: <strong>第二类斯特林数（Stirling numbers of the second kind）</strong>。</p>

\[B_n = \sum\limits_{k = 0}^{n}S(n, k)\]

<h1 id="贝尔数列">贝尔数列</h1>

<p>由贝尔数构成的数列称为贝尔数列</p>
<ul>
  <li>$B_0 = 1$</li>
  <li>$B_1= 1$</li>
  <li>$B_2 = 2$</li>
  <li>$B_3 = 5$</li>
  <li>$B_4 = 15$</li>
  <li>$B_5 = 52$</li>
  <li>…</li>
  <li>$B_{n + 1} = \sum\limits_{k = 0}^{n}C_{n}^{n - k}B_k = \sum\limits_{k = 0}^{n}C_{n}^{k}B_k$</li>
</ul>

<p>递推公式的含义是：对于第 $n + 1$ 个元素，考虑它和前 $n$ 个元素中任意 $n - k$ 个元素被分在同一个子集中，剩下的 $k$ 个元素则自成一种划分（其划分数为
$B_k$）。</p>

<h1 id="贝尔三角形">贝尔三角形</h1>
<p>递推公式在计算上并不是最直观的，更实用的方法是构建一个贝尔三角形来递推计算：</p>
<ul>
  <li>第一行第一项是 $B_0 = 1$</li>
  <li>每一行的第一项是上一行的最后一项</li>
  <li>三角形中的其他项等于它左边项和左上方项之和</li>
</ul>

<p>我们用表格来构建前几项：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">$n$</th>
      <th style="text-align: center">$B_n$</th>
      <th style="text-align: left">贝尔三角形（每行的第一个数就是 $B_n$)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[1]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[1, 2]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[2, 3, 5]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">5</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[5, 7, 10, 15]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">15</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[15, 20, 27, 37, 52]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">52</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[52, 67, 87, 114, 151, 203]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">203</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">...</code></td>
    </tr>
  </tbody>
</table>

<p>动态规划状态转移方程：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="c1">// j &gt; 0</span>
<span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

<span class="n">b_i</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div></div>

<p>这种方法计算起来非常方便，无论是手算还是编程实现</p>]]></content><author><name>devil</name></author><category term="排列组合" /><summary type="html"><![CDATA[贝尔数、贝尔数列、贝尔三角形、第二类斯特林数]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/65.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/65.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">CRC32 校验</title><link href="https://xdevil.top/2025/08/18/CRC32-%E6%A0%A1%E9%AA%8C.html" rel="alternate" type="text/html" title="CRC32 校验" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/18/CRC32%20%E6%A0%A1%E9%AA%8C</id><content type="html" xml:base="https://xdevil.top/2025/08/18/CRC32-%E6%A0%A1%E9%AA%8C.html"><![CDATA[<h1 id="概述">概述</h1>

<p>CRC32 算法有多种变体，主要区别在于 <strong>多项式表示方式（Normal vs Reversed/Reflected）</strong> 和 <strong>初始值、输出异或值等参数</strong>。<code class="language-plaintext highlighter-rouge">0x04C11DB7</code> 和 <code class="language-plaintext highlighter-rouge">0xEDB88320</code> 是同一个多项式的两种不同表示形式，分别用于 <strong>正向 CRC-32</strong> 和 <strong>反向 CRC-32</strong>。</p>

<h1 id="正向-crc-320x04c11db7">正向 CRC-32（0x04C11DB7）</h1>

<h2 id="bitwise">bitwise</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h2 id="look-table">look table</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h1 id="反向-crc-320xedb88320">反向 CRC-32（0xEDB88320）</h1>

<p>常用在 ZIP/GZIP/PNG 等格式中</p>

<h2 id="bitwise-1">bitwise</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">crc32_bitwise</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">crc</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">crc</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xEDB88320</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">crc</span> <span class="o">^</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%02X "</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">crc32_bitwise</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CRC32（十进制）: "</span> <span class="o">&lt;&lt;</span> <span class="n">crc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CRC32（十六进制）: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">crc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="look-table-1">look table</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">CRC32</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">calculate</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">initial</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="mi">256</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="mi">256</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="mi">256</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">{};</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">uint32_t</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">^</span> <span class="p">((</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xEDB88320</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crc</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">;</span>
        <span class="p">}();</span>

        <span class="kt">uint32_t</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">initial</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="n">table</span><span class="p">[(</span><span class="n">crc</span> <span class="o">^</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">crc</span> <span class="o">^</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">calculate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">initial</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">calculate</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">initial</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">calculate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">initial</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">calculate</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">N</span><span class="p">,</span> <span class="n">initial</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%02X "</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">CRC32</span><span class="o">::</span><span class="n">calculate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CRC32（十进制）: "</span> <span class="o">&lt;&lt;</span> <span class="n">crc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CRC32（十六进制）: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">crc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="理论">理论</h1>

<p>？？？？？</p>

<h1 id="链接">链接</h1>

<p><a href="https://www.lddgo.net/encrypt/crc">CRC 在线计算</a></p>]]></content><author><name>devil</name></author><category term="linux" /><summary type="html"><![CDATA[xxxxxx]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/60.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/60.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Kanzi QNX 交叉编译环境搭建</title><link href="https://xdevil.top/2025/08/18/Kanzi-QNX-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" rel="alternate" type="text/html" title="Kanzi QNX 交叉编译环境搭建" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/18/Kanzi%20QNX%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</id><content type="html" xml:base="https://xdevil.top/2025/08/18/Kanzi-QNX-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"><![CDATA[<h1 id="交叉编译工具">交叉编译工具</h1>

<h2 id="qnx710">QNX710</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /opt/qnx710_3/
total 32
drwxrwxr-x 2 pk pk 4096 Oct 23  2022 bsp
drwxrwxr-x 2 pk pk 4096 Oct 23  2022 docs
drwxrwxr-x 6 pk pk 4096 Oct 23  2022 host
<span class="nt">-rwxrwxr-x</span> 1 pk pk  972 Oct 23  2022 qnxsdp-env.bat
<span class="nt">-rwxrwxr-x</span> 1 pk pk 1676 Oct 23  2022 qnxsdp-env.sh
drwxrwxr-x 2 pk pk 4096 Oct 23  2022 <span class="nb">source
</span>drwxrwxr-x 3 pk pk 4096 Oct 23  2022 target
drwxrwxr-x 3 pk pk 4096 Oct 23  2022 targetImages
</code></pre></div></div>

<h2 id="kanzi-交叉编译链">Kanzi 交叉编译链</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /opt/Kanzi-3.9.0-qnx710_screen_aarch64_cxx-es3-freetype-static_libc++/
total 4
drwxr-xr-x 8 root root 4096 Sep 13  2024 Engine
</code></pre></div></div>

<h1 id="clion">CLion</h1>

<p>本文 IDE 使用 CLion 进行开发环境搭建</p>

<h1 id="toolchains">Toolchains</h1>

<p>Settings -&gt; Build, Execution, Deployment -&gt; Toolchains -&gt; + -&gt; System</p>

<ul>
  <li><strong>Name:</strong> QNX710</li>
  <li><strong>Environment file:</strong> /opt/qnx710_3/qnxsdp-env.sh</li>
  <li><strong>CMake:</strong> Bundled
    <ul>
      <li><strong>Build Tool:</strong> Detected ninja</li>
      <li><strong>C Compiler:</strong> /opt/qnx710_3/host/linux/x86_64/usr/bin/ntoaarch64-gcc</li>
      <li><strong>C++ Compiler:</strong> /opt/qnx710_3/host/linux/x86_64/usr/bin/ntoaarch64-g++</li>
    </ul>
  </li>
  <li><strong>Debugger:</strong> Bundled GDB</li>
</ul>

<p><img src="/assets/content/21.png" alt="21.png" /></p>

<h1 id="cmake-profiles">CMake Profiles</h1>

<p>Settings -&gt; Settings -&gt; Build, Execution, Deployment -&gt; CMake-&gt; +</p>

<ul>
  <li><strong>Name:</strong> Release-QNX710</li>
  <li><strong>Build type:</strong> Release</li>
  <li><strong>Toolchain:</strong> QNX710</li>
  <li><strong>Generator:</strong> Use default Ninja</li>
  <li><strong>CMake options:</strong> -DKANZIDIR=/opt/Kanzi-3.9.0-qnx710_screen_aarch64_cxx-es3-freetype-static_libc++</li>
  <li><strong>Build directory:</strong> build</li>
  <li><strong>Build options:</strong> -j 2</li>
</ul>

<p><img src="/assets/content/20.png" alt="20.png" /></p>

<h1 id="cmakelists">CMakeLists</h1>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>www LANGUAGES C CXX<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 14<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD_REQUIRED ON<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -std=gnu++14 -stdlib=libc++"</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_INSTALL_PREFIX <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/output/<span class="si">${</span><span class="nv">CMAKE_BUILD_TYPE</span><span class="si">}</span><span class="p">)</span>

<span class="nb">add_definitions</span><span class="p">(</span>-DQNX<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/<span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/xxx<span class="p">)</span>

<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/xxx/<span class="p">)</span>
</code></pre></div></div>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span> <span class="p">(</span>VERSION 3.10<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>demo<span class="p">)</span>

<span class="nb">add_definitions</span><span class="p">(</span>
    -DQNX_SCREEN
    -DKANZI_FEATURE_3D
    -DKZ_RUNTIME_GRAPHICS_BACKEND=1
    -DKZ_DLOAD_GL_SYMBOLS=12
    -DKZ_SUPPORT_GRAPHICS_API_OPENGL=1
    -DKZ_SUPPORT_GRAPHICS_API_GLES=1
    -DKZ_SUPPORT_GRAPHICS_CONTEXT_API_WGL=1
    -DKZ_SUPPORT_GRAPHICS_CONTEXT_API_EGL=1
    -DKZ_DLOAD_GLES_SYMBOLS=32
    -DKZ_DLOAD_EGL_SYMBOLS=1
    -D_CRT_SECURE_NO_WARNINGS
    -DKZ_INLINE=inline
    <span class="c1">#-D _GLIBCXX_USE_CXX11_ABI=0</span>
    -DWSEGL
<span class="p">)</span>

<span class="nb">add_subdirectory</span> <span class="p">(</span>kanzi<span class="p">)</span>

<span class="nb">file</span><span class="p">(</span>GLOB_RECURSE sources
        *.cpp
        *.h
<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> <span class="si">${</span><span class="nv">sources</span><span class="si">}</span><span class="p">)</span>

<span class="nb">target_include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/include
<span class="p">)</span>

<span class="nb">target_link_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/lib/qnx710_screen_aarch64_cxx/ES3_Release
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/icu/lib
<span class="p">)</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC
        kzappfw
        kzcore
        kzcoreui
        kzui
        kzfreetypeplugin
        screen
        sicuuc
        sicudata
        kanzi
<span class="p">)</span>

<span class="nb">install</span><span class="p">(</span>TARGETS <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> RUNTIME DESTINATION apps<span class="p">)</span>
<span class="nb">install</span><span class="p">(</span>FILES
        <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/xxx.kzb
        <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/datasource.json
        <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/config.json DESTINATION apps<span class="p">)</span>

</code></pre></div></div>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">project</span><span class="p">(</span>kanzi<span class="p">)</span>

<span class="nb">option</span><span class="p">(</span>KANZIPlugin_BUILD_SHARED_LIBS <span class="s2">"Build using shared libraries"</span> OFF<span class="p">)</span>

<span class="nb">file</span><span class="p">(</span>GLOB sources *.h *.hpp *.cpp<span class="p">)</span>

<span class="nb">add_library</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> STATIC <span class="si">${</span><span class="nv">sources</span><span class="si">}</span><span class="p">)</span>

<span class="nb">target_include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/common/boost/include
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/include
<span class="p">)</span>

<span class="nb">target_link_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/lib/qnx710_screen_aarch64_cxx/ES3_Release
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/libunibreak/lib
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/harfbuzz/lib
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/libpng/lib
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/libjpeg/lib
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/freetype/lib
        <span class="si">${</span><span class="nv">KANZIDIR</span><span class="si">}</span>/Engine/libraries/platforms/qnx710-aarch64-cxx/zlib/lib
<span class="p">)</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
        slog2
        kzappfw
        kzcore
        kzcoreui
        kzui
        unibreak
        harfbuzz
        png
        jpeg
        freetype
        GLESv2
        EGL
        z
<span class="p">)</span>

</code></pre></div></div>

<h1 id="rundebug-configurations">Run/Debug Configurations</h1>

<p>点击运行时，由于是交叉编译，程序是无法运行起来的，但编译产物还是要生成并进行打包的，以便推送到运行环境中执行</p>

<p>Run/Debug Configurations -&gt; Before launch -&gt; +</p>

<ul>
  <li><strong>install:</strong> 运行前执行 make install 命令拷贝编译产物到输出路径</li>
  <li><strong>CMake Target: package:</strong> 打包命令，将输出路径下编译产物打包为压缩文件</li>
</ul>

<p><img src="/assets/content/19.png" alt="19.png" /></p>

<h1 id="kanzi-stdio">Kanzi Stdio</h1>
<p>替换 dll 和 license</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># kanzi.lic</span>

C:<span class="se">\P</span>rogramData<span class="se">\R</span>ightware<span class="se">\K</span>anzi<span class="se">\L</span>icenses_Kanzi3
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rlm1212.dll</span>

D:<span class="se">\k</span>anzi3_6_15_63<span class="se">\S</span>tudio<span class="se">\B</span><span class="k">in</span>
</code></pre></div></div>]]></content><author><name>devil</name></author><category term="kanzi" /><category term="qnx" /><summary type="html"><![CDATA[xxxxx]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/61.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/61.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">QNX Coredump 分析</title><link href="https://xdevil.top/2025/08/18/QNX-Coredump-%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="QNX Coredump 分析" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/18/QNX%20Coredump%20%E5%88%86%E6%9E%90</id><content type="html" xml:base="https://xdevil.top/2025/08/18/QNX-Coredump-%E5%88%86%E6%9E%90.html"><![CDATA[<h1 id="cmd">cmd</h1>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> /opt/xxx/qnx710/qnxsdp-env.sh 
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/opt/xxx/qnx710/host/linux/x86_64/usr/bin/ntoaarch64-gdb proc proc.core 
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>where

bt

<span class="o">(</span>gdb<span class="o">)</span> info threads
<span class="o">(</span>gdb<span class="o">)</span> thread apply all bt  <span class="c"># 查看所有线程的调用栈</span>
</code></pre></div></div>]]></content><author><name>devil</name></author><category term="qnx" /><summary type="html"><![CDATA[xxxx]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/62.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/62.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">内存检查工具</title><link href="https://xdevil.top/2025/08/18/%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7.html" rel="alternate" type="text/html" title="内存检查工具" /><published>2025-08-18T00:00:00+00:00</published><updated>2025-08-18T00:00:00+00:00</updated><id>https://xdevil.top/2025/08/18/%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7</id><content type="html" xml:base="https://xdevil.top/2025/08/18/%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7.html"><![CDATA[<h1 id="valgrind">Valgrind</h1>

<h2 id="apt">apt</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 版本老, 存在 valgrind: the 'impossible' happened: Unsupported arch_prctl option 问题</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>valgrind
</code></pre></div></div>

<h2 id="源码编译">源码编译</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1、下载地址: Current Releases

2、解压: <span class="nb">tar </span>xvf valgrind-3.20.0.tar.bz2

3、执行autogen.sh： <span class="nb">cd </span>valgrind-3.20.0 <span class="o">&amp;&amp;</span> ./autogen.sh

如果出现如下错误：./autogen.sh: line 6: aclocal: <span class="nb">command </span>not found error: <span class="k">while </span>running <span class="s1">'aclocal'</span>
缺少依赖，执行如下命令进行安装即可： <span class="nb">sudo </span>apt <span class="nb">install </span>automake
4、配置: ./configure <span class="nt">--prefix</span><span class="o">=</span>/usr/local/valgrind

5、编译: make <span class="nt">-j8</span>

6、安装: <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h2 id="使用">使用</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h1 id="sanitizer">Sanitizer</h1>]]></content><author><name>devil</name></author><category term="linux" /><summary type="html"><![CDATA[Valgrind, Sanitizer 等]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://xdevil.top/assets/image/63.jpeg" /><media:content medium="image" url="https://xdevil.top/assets/image/63.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>