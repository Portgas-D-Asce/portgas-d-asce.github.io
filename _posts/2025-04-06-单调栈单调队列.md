---
layout: page
tags: 栈队列
image: /assets/image/36.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 单调栈单调队列
categories: [计算机, 数据结构与算法]
---

单调栈 / 单调队列：即数组中元素是单调的。但用途不可小觑，常常是效率优化的神器。

# 最大/小栈

```cpp
//实际上就是维护了一个单调递增栈
class MaxStack {
private:
    stack<int> data;
    stack<int> mx;
public:
    void push(int x) {
        data.push(x);
        if(mx.empty() || x >= mx.top()) {
            mx.push(x);
        }
    }
    void pop() {
        if(data.top() == mx.top()) {
            mx.pop();
        }
        data.pop();
    }
    int top() {
        return data.top();
    }
    int max() {
        return mx.top();
    }
    bool empty() {
        return data.empty();
    }
    int size() {
        return data.size();
    }
};
```

[LeetCode 155. 最小栈](https://leetcode.cn/problems/min-stack/)



# prefix first less array

找到数组中每个元素左/右侧第一个比它小的数

```cpp
// 维护的是单调递增栈
// 右侧第一个比它小的数
// 从左到右维护了一个单调递增栈
// 栈顶元素的左侧元素就是它左侧第一个比它小的数（没必要再从后往前跑一遍了）
vector<int> suffix(const vector<int> &nums)	{
    int n = nums.size();
	vector<int> suf(n, n);
	stack<int> s;
	for(int i = 0; i < n; ++i) {
		while(!s.empty() && nums[i] < nums[s.top()]) {
		    suf[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}
    return suf;
}

//左侧第一个比它小的数
//从右到左维护了一个单调递增栈
vector<int> prefix(const vector<int> &nums) {
    int n = nums.size();
    vector<int> pre(n, -1);
	stack<int> s;
	for(int i = n - 1; i >= 0; --i) {
		while(!s.empty() && nums[i] < nums[s.top()]) {
		    pre[s.top()] = i;
			s.pop();
		}
		s.push(i);
	}
    return pre;
}
```

[LeetCode 84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

[LeetCode 85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)



# 最大队列

```cpp
// 实际上就是维护一个单调递减双端队列
class MaxQueue {
private:
    queue<int> data;
    deque<int> mx;
public:
    void push(int x) {
        data.push(x);
        while(!mx.empty() && mx.back() < x) {
            mx.pop_back();
        }
        mx.push_back(x);
    }
    void pop() {
        if(mx.front() == data.front()) {
            mx.pop_front();
        }
        data.pop();
    }
    int front() {
        return data.front();
    }
    int max() {
        return mx.front();
    }
    bool empty() {
        return data.empty();
    }
    int size() {
        return data.size();
    }
};
```



# 长度不超过 k 的最大和子数组

设原数组为 $nums$，其前缀和数组（$prefix\ sum\ array$）为 $sum$，则：
- 以 $nums$ 第 $i$ 项结尾的 长度不超过 $k$ 的子数组的最大和 $mx = sum[i] - min(sum[i - 1], sum[i - 2], ..., sum[i - k])$;
- $min(sum[i - 1], sum[i - 2], ..., sum[i - k])$ 可以通过维护一个长度不超过 $k$ 的最小队列来实现；
```cpp
class MinQueue {
private:
    queue<int> data;
    deque<int> mn;
public:
    void push(int x) {
        data.push(x);
        while(!mn.empty() && mn.back() > x) {
            mn.pop_back();
        }
        mn.push(x);
    }
    void pop() {
        if(data.front() == mn.front()) {
            mn.pop_front();
        }
        data.pop();
    }
    int front()() {
        return data.front();
    }
    int min() {
        return mn.front();
    }
    int size() {
        return data.size();
    }
    bool empty() {
        return data.empty();
    }
};

int max_sum_within_k(const vector<int> &nums, int k) {
    int sum = 0, mx = -2147483648;
    MinQueue mq;
    mq.push(0);
    for(int i = 0; i < nums.size(); ++i) {
        sum += nums[i];
        mx = max(mx, sum - mq.min());
        mq.push(sum);
        if(mq.size() > k) {
            mq.pop();
        }
    }
    return mx;
}
```

思考，按这个思路来考虑 最大和子数组（卡丹算法）也可以这么做：
- 先求 $nums$ 的 前缀和数组 $sum$；
- 遍历 $sum$ 维护一个最小值变量 $mn$，则以 $nums$ 第 $i$ 项结尾的子数组组大和 $mx = sum[i] - mn$；

```cpp
int max_sum(const vector<int> &nums) {
    int mn = 0, sum = 0, mx = -2147483647;
    for(int i = 0; i < nums.size(); ++i) {
        sum += nums[i];
        mx = max(mx, sum - mn);
        mn = min(mn, sum);
    }
    return mx;
}
```

[LeetCode 239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

# 封装

最大/小栈

```cpp
template<typename T>
class MStack {
    using Func = function<bool(const T&, const T&)>;
private:
    stack<T> data;
    stack<T> mx;
    Func comp;
public:
    explicit MStack(Func func = less<T>()) {
        comp = func;
    }
    void push(T x) {
        data.push(x);
        if(mx.empty() || !comp(x, mx.top())) {
            mx.push(x);
        }
    }
    void pop() {
        if(data.top() == mx.top()) {
            mx.pop();
        }
        data.pop();
    }
    T top() const {
        return data.top();
    }
    T m() const {
        return mx.top();
    }
    bool empty() const {
        return data.empty();
    }
    size_t size() const {
        return data.size();
    }
};
```

最大/小队列

```cpp
template<typename T>
class MQueue {
    using Func = function<bool(const T&, const T&)>;
private:
    queue<T> data;
    deque<T> mx;
    Func comp;
public:
    explicit MQueue(Func func = less<T>()) {
        comp = func;
    }
    void push(T x) {
        data.push(x);
        while(!mx.empty() && comp(mx.back(), x)) {
            mx.pop_back();
        }
        mx.push_back(x);
    }
    void pop() {
        if(mx.front() == data.front()) {
            mx.pop_front();
        }
        data.pop();
    }
    T front() const {
        return data.front();
    }
    T m() const {
        return mx.front();
    }
    bool empty() const {
        return data.empty();
    }
    size_t size() const {
        return data.size();
    }
};
```
