---
layout: page
tags: 数据结构与算法 数论
image: /assets/image/21.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 快速幂（Quick Pow）
---

# 原理

快速幂：快速求解 $a^b$ 的方法。

首先，将 $b$ 转为二进制表示：
$$
b = t_0 + t_12 + t_22^2 + ... + t_n2^n \ (t_i = 0\ /\ 1)
$$
问题可转化为：
$$
\begin{aligned}
a^b
& = a^{t_0 + t_12 + t_22^2 + ... + t_n2^n} \\
& = a^{t_0} \times a^{t_12} \times a^{t_22^2} \times ... \times a^{t_n2^n} 
\end{aligned}
$$
可见，$b$ 个 $a$ 相乘的问题被转化为了 $logb$ 项相乘的问题，且每项是前一项的平方（假设 $t_i = 1$）。



# 实现



```cpp
// 注意越界
int qpow(int a, int b, int mod = 1e9 + 7) {
    int res = 1;
    while(b) {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
```





# 应用

## 矩阵快速幂

```cpp
vector<vector<long long>> mul(const vector<vector<long long>> &mat1, const vector<vector<long long>> &mat2, long long mod = 1e9 + 7) {
    int m1 = mat1.size();
    int n1 = mat1[0].size();
    int m2 = mat2.size();
    int n2 = mat2[0].size();
    vector<vector<long long>> res(m1, vector<long long>(n2));
    for(int i = 0; i < m1; ++i) {
        for(int j = 0; j < n2; ++j) {
            for(int k = 0; k < n1; ++k) {
                res[i][j] = (res[i][j] + mat1[i][k] * mat2[k][j]) % mod;
            }
        }
    }
    return res;
}

vector<vector<long long>> qpow(const vector<vector<long long>> &mat, long long x, long long mod = 1e9 + 7) {
    int n = mat.size();
    vector<vector<long long>> res(n, vector<long long>(n));
    for(int i = 0; i < n; ++i) {
        res[i][i] = 1;
    }
    while(x) {
        if(x & 1) res = mul(res, mat);
        mat = mul(mat, mat);
        x >>= 1;
    }
    return res;
}
```



## 超级次方

[372. 超级次方](https://leetcode.cn/problems/super-pow/)
