---
layout: page
tags: 数据结构与算法 组合数学 数论
image: /assets/image/11.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 卢卡斯定理
---

# 卢卡斯定理

## 定理

对于素数 $p$ 、正整数 $m > n$ 在 $p$ 进制下面的表示为：
$$
m = a_0 + a_1p + ... + a_k p^k \\

n = b_0 + b_1p + ... + b_kp^k
$$
则有：
$$
C_m^n \equiv \prod\limits_{i = 0}^{k}{C_{a_i}^{b_i}} \pmod {p}
$$

## 证明

// todo
$$
C_m^n \% m == 0
$$


$$
(x + y)^p \equiv x^p + y^p \pmod {p}
$$


## 实现



```cpp
long long lucas(long long n, long long m, long long p) {
    // 阶乘，1! = 1 * 0!，故 0! = 1
    vector<long long> fact(p + 1);
    fact[0] = 1;
    for(int i = 1; i <= p; ++i) {
        fact[i] = fact[i - 1] * i % p;
    }
    
    // 线性求逆元，要求 p 为素数, 否则除了 0 和 p 还有其它数不存在逆元
    vector<long long> inv(p + 1);
    inv[1] = 1;
    for(int i = 2; i < p; ++i) {
        inv[i] = (p - p / i) * inv[p % i] % p;
    }

    long long res = 1;
    while(m) {
        long long x = n % p, y = m % p;
        if(y > x) return 0;
        long long c = fact[x] * inv[fact[x - y]] % p * inv[fact[y]] % p;
        res = res * c % p;
        n /= p, m /= p;
    }
    return res;
}
```



# 扩展卢卡斯定理

已知三个整数 $1 \le n \le m \le 10^{18}$、$p >= 2$，求：
$$
C_n^m \pmod{p}
$$


## 原理

### $crt$

首先对 $p$ 进行质因数分解
$$
p = p_1^{k_1}p_2^{k2}...p_u^{k_u}
$$
然后依次求解下列余式的值
$$
\left\{\begin{aligned}
C_n^m \mod p_1^{k_1} \\
C_n^m \mod p_2^{k_2} \\
\\
C_n^m \mod p_u^{k_u} \\
\end{aligned}\right.
$$
有了余数 $r_i$，模数 $p_i^{k_i}$，而且模数之间两两互质，使用剩余定理 $crt$ 求出的就是 $C_n^m \pmod{p}$​



### $r_i$ 求解

余数 $r_i \equiv C_n^m \pmod {p_i^{k_i}}$​ 要如何求解呢？卢卡斯定理？不行，模数不是质数。扩展卢卡斯定理通过以下方式求解，

- $x$ 表示 $n!$ 中 $p$ 因子的个数
- $y$ 表示 $m!$ 中 $p$ 因子的个数
- $z$ 表示 $(n - m)!$ 中 $p$ 因子的个数

$$
\begin{aligned}
C_n^m &\equiv \frac{n!}{m!(n - m)!} \pmod {p^k} \\
&\equiv\frac{\frac{n!}{p^x}}{\frac{m!}{p^y}\frac{(n - m)!}{p^z}} p^{x - y - z} \pmod{p^k}
\end{aligned}
$$

除去所有 $p$ 因子后 $\frac{m!}{p^y} \perp p^k$、$\frac{(n - m)!}{p^z} \perp p^k$，两者皆可求逆元。



### $\frac{n!}{p^x}$ 求解

先将阶乘拆分为以下四部分：幂部分、阶乘部分、循环节部分、剩余部分。
$$
\begin{aligned}
n! &\equiv p^{\lfloor \frac{n}{p} \rfloor}(1 * 2 * \cdots * \lfloor \frac{n}{p} \rfloor)\prod\limits_{i = 1, i \not \equiv 0\pmod p}^{p^k} \prod\limits_{i = p^k + 1, i \not \equiv 0\pmod p}^{2p^k} \cdots \prod\limits_{i = p^k \lfloor \frac{n}{p^k} \rfloor + 1, i \not \equiv 0\pmod p}^{n} {\pmod{p^k}}\\
&\equiv p^{\lfloor \frac{n}{p} \rfloor}\lfloor \frac{n}{p} \rfloor!\left(\prod\limits_{i = 1, i \not \equiv 0\pmod p}^{p^k}\right)^{\lfloor \frac{n}{p^k} \rfloor} \prod\limits_{i = p^k \lfloor \frac{n}{p^k} \rfloor + 1, i \not \equiv 0\pmod p}^{n} {\pmod{p^k}}
\end{aligned}
$$


想象将 ${\lfloor \frac{n}{p} \rfloor}!$  全部展开，$p$ 因子移动到左边即得到 $p^x$。进行以下状态定义：
$$
\begin{aligned}
dp[n] &\equiv {\frac{n!}{p^x}} {\pmod{p^k}}\\
&\equiv \lfloor \frac{n}{p} \rfloor!\left(\prod\limits_{i = 1, i \not \equiv 0\pmod p}^{p^k}\right)^{\lfloor \frac{n}{p^k} \rfloor} \prod\limits_{i = p^k \lfloor \frac{n}{p^k} \rfloor + 1, i \not \equiv 0\pmod p}^{n} {\pmod{p^k}}
\end{aligned}
$$
状态转移方程：
$$
dp[n] \equiv dp[{\lfloor \frac{n}{p} \rfloor}]\left(\prod\limits_{i = 1, i \not \equiv 0\pmod p}^{p^k}\right)^{\lfloor \frac{n}{p^k} \rfloor} \prod\limits_{i = p^k \lfloor \frac{n}{p^k} \rfloor + 1, i \not \equiv 0\pmod p}^{n} {\pmod{p^k}}
$$
初始化：
$$
dp[0] = 1
$$

### $C_n^m \pmod{p^k}$​ 求解

使用前一节中推导出的公式 $\frac{n!}{p^x}$、$\frac{m!}{p^y}$、$\frac{(n - m)!}{p^z}$，再使用 $exgcd$ 求后两者的逆元，最后乘以 $p^{x - y - z}$ 即可得到结果。



## 实现

```cpp
// a, b 互质时计算 a 在 mod b 下的逆元 x
pair<long long, long long> exgcd(long long a, long long b) {
    if(b == 0) return {1, 0};
    auto [x, y] = exgcd(b, a % b);
    return {y, x - a / b * y};
}

// 剩余定理，m 中元素两两互质
long long crt(const vector<long long> &r, const vector<long long> &m) {
    long long n = r.size(), mul = 1;
    for(int i = 0; i < n; ++i) mul *= m[i];

    long long res = 0;
    for(int i = 0; i < n; ++i) {
        long long tmp = mul / m[i];
        auto [x, y] = exgcd(tmp, m[i]);
        // 逆元 “标准化”
        x = (x % m[i] + m[i]) % m[i];
        tmp = tmp * x % mul;
        res = (res + (r[i] * tmp) % mul) % mul;
    }
    return (res + mul) % mul;
}

// 质因数分解 [质数，相同质数的乘积]
vector<pair<long long, long long>> factorize(long long x) {
    vector<pair<long long, long long>> factors;
    for(int i = 2; i * i <= x; ++i) {
        if(x % i) continue;
        long long tmp = 1;
        while(x % i == 0) {
            tmp *= i;
            x /= i;
        }
        factors.emplace_back(i, tmp);
    }
    if(x != 1) {
        factors.emplace_back(x, x);
    }
    return factors;
}

// 快速幂
long long qpow(long long a, long long b, long long mod) {
    long long res = 1;
    while(b) {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

// 计算 x! / p^cnt % pk，cnt 表示 x! 中素因子 p 的个数
// 返回结果 [x! / p^cnt % pk, cnt]
pair<long long, long long> dfs(long long x, long long p, long long pk) {
    if(x == 0) return {1, 0};
    long long res = 1;
    // 单个循环节
    for(long long i = 1; i <= pk; ++i) {
        if(i % p) {
            res = res * i % pk;
        }
    }
    
    // 多个循环节
    res = qpow(res, x / pk, pk);
    
    // 循环节之外部分
    for(long long i = 1; i <= x % pk; ++i) {
        if(i % p) {
            res = (res * i) % pk;
        }
    }
    // 动态规划
    auto [fact, cnt] = dfs(x / p, p, pk);
    return {res * fact % pk, cnt + x / p};
}

//计算 C(n, m) % p^k 
long long remainder(long long n, long long m, long long p, long long pk) {
    // fx = n! / p^x % p^k
    auto [fx, x] = dfs(n, p, pk);
    // fy = n! / p^y % p^k
    auto [fy, y] = dfs(m, p, pk);
    // fz = (n - m)! / p^x % p^k
    auto [fz, z] = dfs(n - m, p, pk);
    
    // fy 逆元及标准化
    auto [inv_fy, tmp1] = exgcd(fy, pk);
    inv_fy = (inv_fy % pk + pk) % pk;
    // fz 逆元及标准化
    auto [inv_fz, tmp2] = exgcd(fz, pk);
    inv_fz = (inv_fz % pk + pk) % pk;
    // pow = p^(x - y - z)
    long long pow = qpow(p, x - y - z, pk);
    // C(n, m) % p^k 
    return fx * inv_fy % pk * inv_fz % pk * pow % pk;
}

long long exlucas(long long n, long long m, long long mod) {
    auto factors = factorize(mod);
    // p^k
    vector<long long> ms;
    for(auto [p, pk] : factors) {
        ms.push_back(pk);
    }
    
    // C(n, m) % p^k
    vector<long long> r;
    for(auto [p, pk] : factors) {
        r.push_back(remainder(n, m, p, pk));
    }
    return crt(r, ms);
}
```



# 练习

[P3807 【模板】卢卡斯定理/Lucas 定理](https://www.luogu.com.cn/problem/P3807)

[P4720 【模板】扩展卢卡斯定理/exLucas](https://www.luogu.com.cn/problem/P4720)
