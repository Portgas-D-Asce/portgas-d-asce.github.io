---
layout: page
tags: 设计模式
image: /assets/image/30.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 观察者模式（Observer）
categories: aaa
---

# 概述

## 动机

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关 系” ——一个对象(目标对象)的状态发生改变，所有的依赖对 象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。

使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定 的依赖关系。从而实现软件体系结构的松耦合。

## 定义

定义对象间的一种一对多(变化)的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都 得到通知并自动更新。

## 类图

![/assets/content/2.png](/assets/content/2.png)



# 实现

```cpp
#include <iostream>
#include <set>
using namespace std;

class ISubject;

class IObserver {
public:
    virtual ~IObserver() = default;
    // Subject1 通知消息到来
    virtual void update(ISubject* sub) = 0;
};

class ISubject {
private:
    set<IObserver*> _obs;
public:
    virtual ~ISubject() = default;

    void add(IObserver* ob) {
        _obs.insert(ob);
    }

    void rm(IObserver* ob) {
        _obs.erase(ob);
    }

    // 通知每一个观察者
    void notify() {
        for(IObserver* ob : _obs) {
            ob->update(this);
        }
    }
};

class Observer1 : public IObserver {
public:
    void update(ISubject* sub) override {
        cout << "Observer1 receive change from Subject" << endl;
    }
};

class Observer2 : public IObserver {
public:
    void update(ISubject* sub) override {
        cout << "Observer2 receive change from Subject" << endl;
    }
};

class Subject1 : public ISubject {
public:
    void change() {
        notify();
    }
};

class Subject2 : public ISubject {
public:
    void change() {
        notify();
    }
};

int main() {
    Observer1 ob1;
    Observer2 ob2;
    Subject1 sub1;
    sub1.add(&ob1);
    sub1.add(&ob2);
    sub1.change();

    Subject2 sub2;
    sub2.add(&ob1);
    sub2.add(&ob2);
    sub2.change();


    return 0;
}
```



