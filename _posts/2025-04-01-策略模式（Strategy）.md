---
layout: page
tags: 设计模式
image: /assets/image/26.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 策略模式（Strategy）
categories: [计算机, 设计模式]
---

# 概述

## 动机

在软件构建过程中，某些对象使用的算法可能多种多样，经常改 变，如果将这些算法都编码到对象中，将会使对象变得异常复杂; 而且有时候支持不使用的算法也是一个性能负担。



如何在运行时根据需要透明地更改对象的算法?将算法与对象本 身解耦，从而避免上述问题?

## 定义

定义一系列策略，把它们一个个封装起来，并且使它们可互 相替换(变化)。该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。



# 实现

```cpp
#include <iostream>
using namespace std;

class Algorithm {
public:
    void func1() {
        cout << "Strategy1" << endl;
    }

    void func2() {
        cout << "Strategy2" << endl;
    }

    void func3() {
        cout << "Default Strategy" << endl;
    }

    void run(int type) {
        if(type == 1) {
            func1();
        } else if(type == 2) {
            func2();
        } else {
            func3();
        }
    }
};

int main() {
    Algorithm algorithm1;
    algorithm1.run(1);

    cout << endl;

    Algorithm algorithm2;
    algorithm2.run(2);

    return 0;
}
```

如果需要添加一个新的策略，需要在 Algorithm 中添加新的策略方法，然后在 run 方法中添加条件判断。

- 违背开放原则，扩展时，需要修改 Algorithm 类，没有对修改关闭
- 在 run 中添加条件判断可能会影响原有逻辑
- 如果只需要使用策略 2，但运行时需要逐个判断直到到达策略 2 为止，存在效率问题



```cpp
#include <iostream>
using namespace std;

class IStrategy {
public:
    virtual ~IStrategy() = default;

    virtual void func() = 0;
};

class Strategy1 : public IStrategy {
public:
    void func() override {
        cout << "Strategy1" << endl;
    }
};

class Strategy2 : public IStrategy {
public:
    void func() override {
        cout << "Strategy2" << endl;
    }
};

class Algorithm {
private:
    IStrategy* _strategy;
public:
    explicit Algorithm(IStrategy* strategy) : _strategy(strategy) {}

    void run() {
        _strategy->func();
    }
};

int main() {
    Strategy1 strategy1;
    Algorithm algorithm1(&strategy1);
    algorithm1.run();

    cout << endl;

    Strategy2 strategy2;
    Algorithm algorithm2(&strategy2);
    algorithm2.run();

    return 0;
}
```



就是一个笔筒，想写黑色的字，就给它装黑笔芯，想写红色的字，就给它装红笔芯，...，想写其它颜色的字，就给它装其它颜色的笔芯。符合开闭原则：笔筒的部分是固定不变的（对修改关闭），笔芯是可替换的（对扩展开放）。



这不就是桥模式的一个分支么？

# 应用

Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。

Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。

如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。