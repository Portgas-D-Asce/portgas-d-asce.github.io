---
layout: page
tags: 组合数学 数论
image: /assets/image/19.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: BSGS
categories: [计算机, 数据结构与算法]
---

# bsgs

已知非负整数 $a$ 、 $b$ 和正数 $p$，$a \neq 0$ 时 $a, p$ 互质，求以下同余方程的最小非负数整数解，无解时输出 $-1$


$$
a^x \equiv b(mod p)
$$

$0^0 = 1$，以下为一些特殊场景

- 当 $b == 1$ 时，$x = 0$​
- 当 $p == 1$ 时，$x = 0$

- 当 $a == 0$ 时：当 $b == 0$ 时，$x = 1$；当 $b > 1$ 时，无解



## BF

从 $0$ 开始枚举 $x$ ，最多循环 $p$ 次即可得到结论：最小整数解 或 无解

```cpp
int res = 1;
int x = 1;
while(res != b) {
    res = res * a % p;
}
```

时间复杂度 $O(p)$



## bsgs

大小步算法（baby-step giant-step, BSGS）可以在 $\sqrt{p}$ 时间复杂度下得到结论，要求 $a$ 和 $p$ 互质。



假设 $x = A \lceil {\sqrt{p}} \rceil - B$，其中 $0\le B \le \lceil{\sqrt{p}} \rceil$，$1\le A \le \lceil{\sqrt{p}} \rceil$，带入方程后有：

$$
a^{A \lceil {\sqrt{p}} \rceil - B} \equiv b(mod p) \\
a^{A \lceil {\sqrt{p}} \rceil} \equiv ba^{B}(mod p)
$$

算法步骤：

- 先枚举右侧 $B$ 并将取余结果保存到 `map` 中
- 然后再枚举左侧 $A$​ 
    - 当其取余结果在 `map` 中存在时，则说明找到答案
    - 否则说明无解。



时间复杂度 $O(\sqrt{p})$



为什么 bsgs 找到的是最小的 $x$ ？

- 当右侧出现相同余数时，大的 $B$ 会覆盖小的 $B$
- $A$ 是从小到大开始枚举的。



## 实现

```cpp
template<typename T>
T bsgs(T a, T b, T mod) {
    a %= mod, b %= mod;
    if(b == 1 || mod == 1) return 0;
    if(a == 0) return b == 0 ? 1 : -1;
    // 仅适用非互质场景
    //if(gcd(a, mod) != 1) exit(1);

    map<T, T> mp = {{b, 0}};

    T bs = 1, n = sqrt(mod * 1.0) + 1;
    for(T i = 1; i <= n; ++i) {
        bs = bs * a % mod;
        mp[b * bs % mod] = i;
    }

    for(T i = 1, gs = bs; i <= n; ++i) {
        if(mp.find(gs) != mp.end()) {
            return i * n - mp[gs];
        }
        gs = gs * bs % mod;
    }
    return -1;
}
```

# exbsgs

$a^{A \lceil {\sqrt{p}} \rceil} \equiv ba^{B}(mod p)$ 成立后，想恢复为 $a^{A \lceil {\sqrt{p}} \rceil - B} \equiv b(mod p)$，要求 $a^B$ 在 $mod p$ 下有逆元，也就是 $a$ 和 $p$ 互质。



这就是 $bsgs$ 不适用于 $a$ 和 $p$ 不互质场景的原因。

## 原理

通过简单操作，将非互质问题转化为互质问题，然后再按照普通 bsgs 求解即可。



求解以下同余式，最小非负整数解

$$
a^{x} \equiv b(modp)
$$

将同余式展开

$$
a^{x} + kp = b
$$

设 $gcd(a, p) = d$，两边同除以 $d$

$$
\frac{a}{d} a^{x - 1} + k\frac{p}{d} = \frac{b}{d}
$$

两边取模 $\frac{p}{d}$ 转化为同余式

$$
\frac{a}{d} a^{x - 1} \equiv \frac{b}{d}(mod\frac{p}{d})
$$

$\frac{a}{d} \perp \frac{p}{d}$ 存在逆元。问题转化为互质场景了吗？没有，$a$ 、$\frac{p}{d}$ 不一定互质

$$
a^{x - 1} = \frac{b}{d}(\frac{a}{d})^{-1}(mod\frac{p}{d})
$$

 需要重复操作，直到互质为止。假设重复了 $cnt$ 次，最小公倍数的累积值为 $d_{cnt}$。则有

$$
a^{x - cnt} = \frac{b}{d_{cnt}}(\frac{a^{cnt}}{d_{cnt}})^{-1}(mod\frac{p}{d_{cnt}})
$$

$a \perp \frac{p}{d_{cnt}}$ 问题转化为了互质场景！ 



## 实现

```cpp
pair<long long, long long> exgcd(long long a, long long b) {
    if(b == 0) return {1, 0};
    auto [x, y] = exgcd(b, a % b);
    return {y, x - a / b * y};
}

template<typename T>
T exbsgs(T a, T b, T mod) {
    a %= mod, b %= mod;
    if(b == 1 || mod == 1) return 0;
    if(a == 0) return b == 0 ? 1 : -1;
    
    // 将非互质场景，转化为互质场景
    T total = 1, d = 0, cnt = 0;
    while((d = gcd(a, mod)) != 1) {
        if(b % d) return -1;
        cnt++, b /= d, mod /= d;
        total = total * (a / d) % mod;
        // 如果已经找到结果直接返回
        if(total == b) return cnt;
    }
    // 求解 total 逆元
    auto [x, y] = exgcd(total, mod);
    // total 逆元 “标准化”
    x = (x % mod + mod) % mod;
    // 更新 b 值
    b = b * x % mod;
    
    // 已转化为了互质场景，直接求解
    map<T, T> mp = {{b, 0}};
    T bs = 1, n = sqrt(mod * 1.0) + 1;
    for(T i = 1; i <= n; ++i) {
        bs = bs * a % mod;
        mp[b * bs % mod] = i;
    }

    for(T i = 1, gs = bs; i <= n; ++i) {
        if(mp.find(gs) != mp.end()) {
            return i * n - mp[gs] + cnt;
        }
        gs = gs * bs % mod;
    }
    return -1;
}
```



# 练习

[P4884 多少个 1？](https://www.luogu.com.cn/problem/P4884?contestId=10238)

[P3846 [TJOI2007] 可爱的质数/【模板】BSGS](https://www.luogu.com.cn/problem/P3846)

[P4195 【模板】扩展 BSGS/exBSGS](https://www.luogu.com.cn/problem/P4195)

