---
layout: page
tags: 设计模式
image: /assets/image/23.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 桥模式（Bridge）
categories: [计算机, 设计模式]
---

# 概述

由于某些类型的固有实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化



如何应对这种 “多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？



## 模式定义

将抽象部分（业务功能）与实现部分（平台实现）分离，使得它们可以独立地变化



**将多个变化维度分离，使得它们可以独立地变化。**



# 实现

## 继承方式

```cpp
#include <iostream>
using namespace std;

class ILeftRight {
public:
    // Left 抽象
    virtual void func1() = 0;

    // Right 抽象
    virtual void func2() = 0;
};

class ILeft1 : public ILeftRight {
public:
    void func1() override {
        cout << "Left1" << endl;
    }
};

class ILeft2 : public ILeftRight {
public:
    void func1() override {
        cout << "Left2" << endl;
    }
};

class Left1Right1 : public ILeft1 {
public:
    void func2() override {
        cout << "Right1" << endl;
    }
};

class Left1Right2 : public ILeft1 {
public:
    void func2() override {
        cout << "Right2" << endl;
    }
};

class Left2Right1 : public ILeft2 {
public:
    void func2() override {
        cout << "Right1" << endl;
    }
};

class Left2Right2 : public ILeft2 {
public:
    void func2() override {
        cout << "Right2" << endl;
    }
};


int main() {
    // 编译时装配
    Left2Right2 l2r2;
    l2r2.func1();
    l2r2.func2();

    return 0;
}
```

可以实现不同维度的任意搭配，但不够灵活，类种类 $n * m$



## 桥模式

```cpp
#include <iostream>
using namespace std;

class ILeft {
public:
    virtual void func() = 0;
    virtual ~ILeft() = default;
};

class Left1 : public ILeft {
public:
    void func() override {
        cout << "Left1" << endl;
    }
};

class Left2 : public ILeft {
public:
    void func() override {
        cout << "Left2" << endl;
    }
};

class IRight {
public:
    virtual void func() = 0;
    virtual ~IRight() = default;
};

class Right1 : public IRight {
public:
    void func() override {
        cout << "Right1" << endl;
    }
};

class Right2 : public IRight {
public:
    void func() override {
        cout << "Right2" << endl;
    }
};

class Bridge {
private:
    ILeft* _left;
    IRight* _right;
public:
    Bridge(ILeft* left, IRight* right) : _left(left), _right(right) {}

    void run() {
        _left->func();
        _right->func();
    }
};


int main() {
    // 运行时装配
    Left1 left1;
    Right2 right2;
    Bridge b(&left1, &right2);
    b.run();

    return 0;
}
```



# 应用

