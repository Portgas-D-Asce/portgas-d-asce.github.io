# 二叉树序列化与反序列化

二叉树的序列化，可以按照中序遍历、后序遍历、层序遍历、先序遍历（后两者居多）等方式进行转换。通常做法是： 

- 二叉树节点值之间用 空格 或 逗号 隔开；
- 空子树用 # 等字符表示；

下面以层序遍历的方式进行序列化和反序列化实现。

```cpp
string serialize(TreeNode* root) {
    if(!root) return "";

    string res = to_string(root->val) + " ";

    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty())
    {
        TreeNode* visiting = q.front();
        q.pop();
        
        if(visiting->left)
        {
            res += to_string(visiting->left->val);
            q.push(visiting->left);
        }
        else
        {
            res += "#";
        }
        res += " ";

        if(visiting->right)
        {
            res += to_string(visiting->right->val);
            q.push(visiting->right);
        }
        else
        {
            res += "#";
        }
        res += " ";
    }
    return res;
}

TreeNode* deserialize(string s) {
    if(s.empty()) return nullptr;
    queue<TreeNode*> q;
    int i = 0;
    string value;
    while(s[i] != ' ')
        value += s[i++];
    ++i;

    TreeNode* root = new TreeNode(stoi(value));
    q.push(root);
    
    while(i < s.size())
    {
        TreeNode* parent = q.front();
        q.pop();

        value = "";
        while(s[i] != ' ')
            value += s[i++];
        ++i;
        if(value != "#")
        {
            parent->left = new TreeNode(stoi(value));
            q.push(parent->left);
        }

        value = "";
        while(s[i] != ' ')
            value += s[i++];
        ++i;
        if(value != "#")
        {
            parent->right = new TreeNode(stoi(value));
            q.push(parent->right);
        }
        
    }
    return root;
}
```

# 练习

[LeetCode 94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)
[LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
[LeetCode 297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)







# 相同的树

题目直达：[LeetCode 100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

## 分析

依次比较两棵树中的节点：

- 如果 两个节点均不存在/两个节点存在且值相等 则继续比较他们两个左子树/右子树是否分别相等；
- 否则，两棵树不相同；

## 代码

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr) return true;
        if(p == nullptr || q == nullptr) return false;
        if(p->val != q->val) return false;
        bool flag1 = isSameTree(p->left, q->left);
        bool flag2 = isSameTree(p->right, q->right);
        return flag1 && flag2;
    }
};
```

# 对称二叉树

题目直达：[LeetCode 101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

## 分析

对于两个处于对称位置的节点 left 和 right：

- 比较 left->left 和 right->right 两棵子树是否对称；
- 比较 left->right 和 right->left 两棵子树是否对称；
- 如果两者皆对称，则说明 left 和 right 对称；

## 代码

```cpp
class Solution {
public:
    bool recursion(TreeNode *left, TreeNode *right) {
        if(left == nullptr && right == nullptr) return true;
        if(left == nullptr || right == nullptr) return false;
        if(left->val != right->val) return false;
        bool flag1 = recursion(left->left, right->right);
        bool flag2 = recursion(left->right, right->left);
        return flag1 && flag2;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return recursion(root->left, root->right);
    }
};
```



# 镜像二叉树

LeetCode 226. Invert Binary Tree

```
void mirror(TreeNode* root){
    if(!root) return;
    swap(root->left, root->right);
    mirror(root->left);
    mirror(root->right);
}
```

