---
layout: page
tags: 计算几何
image: /assets/image/49.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 旋转卡壳
categories: [计算机, 数据结构与算法]
---

# 概述

## 切线

过凸包上一点的线，如果凸包全部位于线的一侧，则称该线为凸包的切线



## 对踵点

过凸包上两点作两条相互平行的直线，且凸包位于两条平行线之间，则这两个点称作为对踵点。有三种情况：

- 点点对踵：
- 点边对踵：包含两对对踵点
- 边边对踵：包含四对对踵点

可以证明，一个凸 边形的对踵点最多只有 $3n/2$ 对(上取整)。



## 旋转卡壳

凸包的很多问题都是使用旋转卡壳思想解决的。



# 凸包直径

凸多边形的直径：将一个凸多边形上任意两点间的距离的最大值定义为多边形的直径。确定这个直径的点对数可能多于一对



> **存在一个凸多边形直径定理：凸多边形P的直径 的所有平行支撑线之间距离的最大值，因此，凸多边形的直径可以在对踵点对之间寻找** 如何证明？？？？？？？？？？
>
> 



## 原理

逆时针遍历凸包上的边，并找到离其最远的点（对踵点）。随着边的旋转，最远点也在逆时针旋转，旋转期间维护最长直径。



步骤：

- 对于每条边，都检查，下一个点是否比当前点离边更远
    - 如果是，则前进到下一个点，接着判断
    - 如果不是，则说明最远点已经找到了，计算当前边的两个端点与最远点的距离，并与当前最长直径比较。
- 当遍历完所有边后，即可得到最长直径



## 实现

凸包计算

```cpp
// (p1, p2) x (p1, p3)
template<typename T>
T cross(const pair<T, T> &p1, const pair<T, T> &p2, const pair<T, T> &p3) {
    return (p2.first - p1.first) * (p3.second - p1.second) -
           (p3.first - p1.first) * (p2.second - p1.second);
}

// 返回值末尾包含起点
template<typename T>
vector<pair<T, T>> andrew(vector<pair<T, T>> &pts) {
    // 0 个点和 1 个点都返回点集自身
    if(pts.size() < 2) return pts;
    
    // 包含 2 个点、3 个点情况，且都会追加起始点
    auto start = [&pts](int p, int r, vector<pair<T, T>> &stk) {
        int step = p < r ? 1 : -1;
        int base = stk.size() + (step > 0);
        for(int i = p; i != r; i += step) {
            for(int j = stk.size(); j > base; --j) {
                if(cross(stk[j - 1], stk[j - 2], pts[i]) < 0) break;
                stk.pop_back();
            }
            stk.push_back(pts[i]);
        }
    };
    
    sort(pts.begin(), pts.end());

    int n = pts.size();
    vector<pair<T, T>> res;
    start(0, n, res);
    start(n - 2, -1, res);
    return res;
}
```



凸包直径计算

```cpp
template<typename T>
T dist2(const pair<T, T> &p, const pair<T, T> &q) {
    return (q.first - p.first) * (q.first - p.first) +
           (q.second - p.second) * (q.second - p.second);
};

// 输入为逆序凸包顶点，末尾重复起点
template<typename T>
T rotating_calipers(const vector<pair<T, T>> &pts) {
    if(pts.size() <= 2) return 0;
    
    T mx = dist(pts[0], pts[1]);
    if(pts.size() == 3) return mx;
    
    // 不算末尾重复的起点
    int n = pts.size() - 1;
    for(int i = 1, j = 2; i <= n; ++i) {
        // 寻找当前边的对踵点
        while(cross(pts[(j + 1) % n], pts[i - 1], pts[i]) > cross(pts[j], pts[i - 1], pts[i])) {
            j = (j + 1) % n;
        }
        // 两对对踵点之间距离的最大值
        mx = max(mx, dist(pts[i - 1], pts[j]));
        mx = max(mx, dist(pts[i], pts[j]));
    }
    return mx;
}
```



## 复杂度

时间复杂度：$O(n)$

空间复杂度：$O(1)$



# 凸包的宽度

凸包的宽度定义为平行切线间的最小距离

## 原理

找到所有的点边对踵，并计算点到边的距离，维护一个最小值就是凸包的宽度

## 实现

类似于凸包直径，叉积有了，边的长度也有了，三角形的高自然也有了，旋转过程中维护最小的高即可。



## 复杂度

时间复杂度：$O(n)$

空间复杂度：$O(1)$​



# 最小矩形

涉及两个问题，面积最小矩形 和 周长最小矩形，两者基本一样。这里以面积最小为例。

## 原理

面积最小的外接矩形一定有一条边与凸包的边重合。因此，固定一条边，其它三条边就确定了，旋转过程中维护面积最小值。



注意：周长最小矩形原理与面积最小矩形一样，只不过在旋转过程中维护的是最小周长而已。



## 实现

旋转过程中维护三个点，逆时针旋转边的时候，这三个点也在跟着旋转

- 上边点是使用叉积来选择的
- 左右两边的点是通过点积来选择的
- **注意右侧点初始值的选择**



```cpp
template<typename T>
T dot(const pair<T, T> &p1, const pair<T, T> &p2, const pair<T, T> &p3) {
    return (p2.first - p1.first) * (p3.first - p1.first) + (p2.second - p1.second) * (p3.second - p1.second);
}

template<typename T>
double mn_rec(vector<pair<T, T>> &pts, vector<pair<double, double>> &rec) {
    if(pts.size() < 4) return 0;

    double res = 1e9;
    int n = pts.size() - 1;
    for(int i = 1, p = 1, q = 1, r = 1; i <= n; ++i) {
        // 查找上边的点
        while(cross(pts[(q + 1) % n], pts[i - 1], pts[i]) > cross(pts[q], pts[i - 1], pts[i])) {
            q = (q + 1) % n;
        }

        // 查找右侧的点
        while(dot(pts[i - 1], pts[i], pts[(p + 1) % n]) > dot(pts[i - 1], pts[i], pts[p])) {
            p = (p + 1) % n;
        }
        
        // 左侧点初始值
        if(i == 1) r = q;
        // 查找左侧的点
        while(dot(pts[i], pts[i - 1], pts[(r + 1) % n]) > dot(pts[i], pts[i - 1], pts[r])) {
            r = (r + 1) % n;
        }
        
        // 右侧点与当前边的点积
        T temp1 = dot(pts[i - 1], pts[i], pts[p]);
        // 左侧点与当前边的点积
        T temp2 = dot(pts[i], pts[i - 1], pts[r]);
        // 当前边与自己的点积
        T temp3 = dot(pts[i - 1], pts[i], pts[i]);
        // 以当前边为底的三角形的面积
        T s = cross(pts[i - 1], pts[i], pts[q]);
        // h = s / sqrt(temp3)
        // w = 两个投影之和减去当前边长度
        double temp = s * (temp1 + temp2 - temp3) / (1.0 * temp3);
        res = min(res, temp);
    }
    return res;
}
```



## 复杂度

时间复杂度：$O(n)$​

空间复杂度：$O(1)$​



# 凸包距离(todo)

有两种情况，最大距离比较简单，最小距离相对复杂。

最大距离

- 两个点分别位于两个凸包上，求两个点的最大距离

- 显然，这两个点一定是凸包的顶点



最小距离：

- 两个点分别位于两个凸包上，求两个点的最小距离
- 这两个点不一定都是顶点



## 原理



## 实现



## 复杂度





# 练习

[P1452 【模板】旋转卡壳 | [USACO03FALL] Beauty Contest G](https://www.luogu.com.cn/problem/P1452)

[P3187 [HNOI2007] 最小矩形覆盖](https://www.luogu.com.cn/problem/P3187)

[P3829 [SHOI2012] 信用卡凸包](https://www.luogu.com.cn/problem/P3829)



# 参考

[旋转卡壳](https://oi-wiki.org/geometry/rotating-calipers/)
