---
layout: page
image: /assets/image/1.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 多态实现原理（非虚继承）
categories: [计算机, CC++]
---

# 虚函数

## 虚函数

```cpp
class A {
public:
    virtual void func() {
        cout << "virtual func" << endl;
    };
};
```

## 纯虚函数

```cpp
class A {
public:
    virtual void func() = 0;
};
```

纯虚函数：
- 纯虚函数就是只有声明，没有定义的虚函数；以“=0”结尾；
- 纯虚函数的目的就是：提供一个统一的接口（也可以说是：为所有继承它的类制定统一标准）；
- 与虚函数不同，无法直接调用纯虚函数，必须通过多态的形式对其进行调用；

纯虚函数存在的意义
- 制定标准
    - 纯虚函数是为程序制定一种标准，只要你继承了它，就必须按照它的标准来，实现它的所有的方法，否则你也是虚拟的；
    - 制定标准是为了让所有实现它或继承自它的派生类类全部按同一标准来工作，从而使程序更加通用化，提高程序的可重用性；
- 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理；
- 父类中存在纯虚函数，子类中重写（override）该函数，可实现多态；


## 抽象类
包含纯虚函数的类叫做抽象类，抽象类无法进行实例化。

必须在派生类中对抽象类中的所有纯虚函数进行重写，否则该类也是一个抽象类。


# GDB 调试

```cpp
#include <iostream>

class Base1 {
public:
    virtual void func1() {
        std::cout << "base1::func1()" << std::endl;
    }
    virtual void func2() {
        std::cout << "base1::func2()" << std::endl;
    }
    virtual ~Base1() {
        std::cout << "base1::~base1()" << std::endl;
    }
private:
    int b1;
};

class Base2 {
public:
    virtual void func3() {
        std::cout << "base2::func3()" << std::endl;
    }
    virtual void func4() {
        std::cout << "base2::func4()" << std::endl;
    }
    virtual ~Base2() {
        std::cout << "base2::~base2()" << std::endl;
    }
private:
    int b2;
};


class Derive : public Base1, public Base2 {
public:
    void func1() override {
        std::cout << "derive::func1()" << std::endl;
    }
    void func2(int x) {
        std::cout << "derive::func2()" << std::endl;
    }
    void func3() override {
        std::cout << "derive::func3()" << std::endl;
    }
    virtual void func5() {
        std::cout << "derive::func5()" << std::endl;
    }
    virtual void func6() {
        std::cout << "derive::func6()" << std::endl;
    }
    virtual ~Derive() {
        std::cout << "derive::~derive()" << std::endl;
    }
private:
    int c;
};

int main() {
    Base1 a;
    Base2 b;

    Derive c;

    return 0;
}
```



## __class_type_info

首先看下这几个东西：

- `__cxxabiv1::__class_type_info`
- `__cxxabiv1::__class_type_info@@CXXABI_1.3`
- `__cxxabiv1::__vmi_class_type_info`
- `__cxxabiv1::__vmi_class_type_info@@CXXABI_1.3`

```bash
# (gdb) info variables
...
0x000000000041fd18  vtable for __cxxabiv1::__class_type_info
0x000000000041fd18  vtable for __cxxabiv1::__class_type_info@@CXXABI_1.3
0x000000000041fd70  vtable for __cxxabiv1::__vmi_class_type_info
0x000000000041fd70  vtable for __cxxabiv1::__vmi_class_type_info@@CXXABI_1.3
...
```

```bash
(gdb) x/50xg 0x000000000041fd18
0x41fd18 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3>:   0x0000000000000000      0x0000fffff7fafb50
0x41fd28 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3+16>:        0x0000fffff7ea9110      0x0000fffff7ea9128
0x41fd38 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3+32>:        0x0000fffff7eabdf0      0x0000fffff7eabdf0
0x41fd48 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3+48>:        0x0000fffff7ea9290      0x0000fffff7ea9070
0x41fd58 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3+64>:        0x0000fffff7ea9228      0x0000fffff7ea9150
0x41fd68 <_ZTVN10__cxxabiv117__class_type_infoE@@CXXABI_1.3+80>:        0x0000fffff7ea9100      0x0000000000000000
0x41fd78 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+8>:     0x0000fffff7fb0800      0x0000fffff7eac5f0
0x41fd88 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+24>:    0x0000fffff7eac608      0x0000fffff7eabdf0
0x41fd98 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+40>:    0x0000fffff7eabdf0      0x0000fffff7ea9290
0x41fda8 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+56>:    0x0000fffff7ea9070      0x0000fffff7eaccd0
0x41fdb8 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+72>:    0x0000fffff7eac750      0x0000fffff7eac630
(gdb) x/50xg 0x000000000041fd70
0x41fd70 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3>:       0x0000000000000000      0x0000fffff7fb0800
0x41fd80 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+16>:    0x0000fffff7eac5f0      0x0000fffff7eac608
0x41fd90 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+32>:    0x0000fffff7eabdf0      0x0000fffff7eabdf0
0x41fda0 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+48>:    0x0000fffff7ea9290      0x0000fffff7ea9070
0x41fdb0 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+64>:    0x0000fffff7eaccd0      0x0000fffff7eac750
0x41fdc0 <_ZTVN10__cxxabiv121__vmi_class_type_infoE@@CXXABI_1.3+80>:    0x0000fffff7eac630      0x0000000000000001
```



## 结构信息

编译器为类创建了一些结构信息：虚表、类型信息、 类名等。

### 存储位置

结构信息的存储位置

```bash
# (gdb) info variables
...
0x00000000004010e0  vtable for Derive
0x0000000000401158  vtable for Base2
0x0000000000401188  vtable for Base1
0x00000000004011b8  typeinfo for Derive
0x00000000004011f0  typeinfo name for Derive
0x00000000004011f8  typeinfo for Base2
0x0000000000401208  typeinfo name for Base2
0x0000000000401210  typeinfo for Base1
0x0000000000401220  typeinfo name for Base1
...
```



### 存储结构

结构信息的整体布局

- \_ZTV6Derive，\_ZTV5Base2，\_ZTV5Base1
- \_ZTI6Derive，\_ZTS6Derive
- \_ZTI5Base2，\_ZTS5Base2
- \_ZTI5Base1，\_ZTS5Base1



> \_ZTV、\_ZTI、\_ZTS 前缀的含义？
>
> - _ZTV：保存着类的虚表（type-virtual）
> - _ZTI：保存着类的类型结构（type-info）
> - _ZTS：存储着类的名字（type-string）



> \_ZTV6Derive+16 的含义？
>
> - _ZTV：表示虚表
> - 6：表示类名的长度
> - Derive：类名
> - +16：表示地址偏移量



```bash
(gdb) x/45xg 0x00000000004010e0
0x4010e0 <_ZTV6Derive>: 0x0000000000000000      0x00000000004011b8
0x4010f0 <_ZTV6Derive+16>:      0x0000000000400d30      0x0000000000400b80
0x401100 <_ZTV6Derive+32>:      0x0000000000400e38      0x0000000000400eb4
0x401110 <_ZTV6Derive+48>:      0x0000000000400d70      0x0000000000400db8
0x401120 <_ZTV6Derive+64>:      0x0000000000400df8      0xfffffffffffffff0
0x401130 <_ZTV6Derive+80>:      0x00000000004011b8      0x0000000000400db0
0x401140 <_ZTV6Derive+96>:      0x0000000000400c78      0x0000000000400eac
0x401150 <_ZTV6Derive+112>:     0x0000000000400edc      0x0000000000000000
0x401160 <_ZTV5Base2+8>:        0x00000000004011f8      0x0000000000400c38
0x401170 <_ZTV5Base2+24>:       0x0000000000400c78      0x0000000000400cb8
0x401180 <_ZTV5Base2+40>:       0x0000000000400d08      0x0000000000000000
0x401190 <_ZTV5Base1+8>:        0x0000000000401210      0x0000000000400b40
0x4011a0 <_ZTV5Base1+24>:       0x0000000000400b80      0x0000000000400bc0
0x4011b0 <_ZTV5Base1+40>:       0x0000000000400c10      0x000000000041fd80
0x4011c0 <_ZTI6Derive+8>:       0x00000000004011f0      0x0000000200000000
0x4011d0 <_ZTI6Derive+24>:      0x0000000000401210      0x0000000000000002
0x4011e0 <_ZTI6Derive+40>:      0x00000000004011f8      0x0000000000001002
0x4011f0 <_ZTS6Derive>: 0x0065766972654436      0x000000000041fd28
0x401200 <_ZTI5Base2+8>:        0x0000000000401208      0x0000326573614235
0x401210 <_ZTI5Base1>:  0x000000000041fd28      0x0000000000401220
0x401220 <_ZTS5Base1>:  0x0000316573614235      0x000000f43b031b01
(gdb) print (char *)0x4011f0
$2 = 0x4011f0 <typeinfo name for Derive> "6Derive"
(gdb) print (char *)0x401208
$3 = 0x401208 <typeinfo name for Base2> "5Base2"
(gdb) print (char *)0x401220
$4 = 0x401220 <typeinfo name for Base1> "5Base1"
(gdb) info vtbl a
vtable for 'Base1' @ 0x401198 (subobject @ 0xfffffffffb20):
[0]: 0x400b40 <Base1::func1()>
[1]: 0x400b80 <Base1::func2()>
(gdb) info vtbl b
vtable for 'Base2' @ 0x401168 (subobject @ 0xfffffffffb10):
[0]: 0x400c38 <Base2::func3()>
[1]: 0x400c78 <Base2::func4()>
(gdb) info vtbl c
vtable for 'Derive' @ 0x4010f0 (subobject @ 0xfffffffffaf0):
[0]: 0x400d30 <Derive::func1()>
[1]: 0x400b80 <Base1::func2()>
[2]: 0x400e38 <Derive::~Derive()>
[3]: 0x400eb4 <Derive::~Derive()>
[4]: 0x400d70 <Derive::func3()>
[5]: 0x400db8 <Derive::func5()>
[6]: 0x400df8 <Derive::func6()>

vtable for 'Base2' @ 0x401138 (subobject @ 0xfffffffffb00):
[0]: 0x400db0 <non-virtual thunk to Derive::func3()>
[1]: 0x400c78 <Base2::func4()>

(gdb) x/xg 0x0000000000400db0
0x400db0 <_ZThn16_N6Derive5func3Ev>:    0x17ffffefd1004000
(gdb) x/xg 0x0000000000400eac
0x400eac <_ZThn16_N6DeriveD1Ev>:        0x17ffffe2d1004000
(gdb) x/xg 0x0000000000400edc
0x400edc <_ZThn16_N6DeriveD0Ev>:        0x17fffff5d1004000

(gdb) disas 0x0000000000400db0
Dump of assembler code for function _ZThn16_N6Derive5func3Ev:
   0x0000000000400db0 <+0>:     sub     x0, x0, #0x10
   0x0000000000400db4 <+4>:     b       0x400d70 <Derive::func3()>
End of assembler dump.
(gdb) disas 0x0000000000400eac
Dump of assembler code for function _ZThn16_N6DeriveD1Ev:
   0x0000000000400eac <+0>:     sub     x0, x0, #0x10
   0x0000000000400eb0 <+4>:     b       0x400e38 <Derive::~Derive()>
End of assembler dump.
(gdb) disas 0x0000000000400edc
Dump of assembler code for function _ZThn16_N6DeriveD0Ev:
   0x0000000000400edc <+0>:     sub     x0, x0, #0x10
   0x0000000000400ee0 <+4>:     b       0x400eb4 <Derive::~Derive()>
End of assembler dump.
```



# Virtual Table

## 虚表结构

虚表部分 _ZTV 开头，多继承会导致有多块虚表，每块虚表以一个 16 字节的头部开始

- 虚表1

    - 头部前 8 个字节：top offset，通常为 0；虚指针地址 + 偏移量 = 对象首地址
      
    - 头部后 8 字节：指向当前类的 type-info 地址（_ZTI）
      
    - 内容：虚函数指针1、虚函数指针2 ... 虚函数指针 n
    
- 虚表2

    - 头部前 8 个字节：top offset 0xfffffffffffffff0 = -16 虚指针地址 + 偏移量 = 对象首地址
    
    - 头部后 8 字节：指向当前类的 type-info 地址（_ZTI）
    - 内容：虚函数指针1、虚函数指针2 ... 虚函数指针 n



## non-virtual thunk

`[0]: 0x400db0 <non-virtual thunk to Derive::func3()>`、`0x400eac`、 `0x400edc` 这几处内存比较奇怪，存储的好像并非某个虚函数的指针，查看内存信息如下：

- `0x400db0 <_ZThn16_N6Derive5func3Ev>`
- `0x400eac <_ZThn16_N6DeriveD1Ev>`
- `0x400edc <_ZThn16_N6DeriveD0Ev>`



是的，这些内存保存的不是虚函数指针，而是 8 字节的指令，反汇编之后发现有两条命令：

- `0x0000000000400db0 <+0>:     sub     x0, x0, #0x10`：偏移基类 this 指针，使其指向派生类的 this 指针
-  `0x0000000000400db4 <+4>:     b       0x400d70 <Derive::func3()>`：跳转到派生类的重写函数上去



通过上面两条指令可以引导执行派生类中的虚函数，这也就是所谓的  `non-virtual thunk` 技术。



> `Base1 *p1 = new Derive();` 和 `Base2 *p2 = new Derive();` 两个指针分别指向什么位置？
>
> - `p1` 指向 `Derive::_vptr.Base1` ，与对象的起始地址是一样的，也就是偏移量为 0
> - `p2` 指向 `Derive::_vptr.Base2`，与对象的起始地址不同，偏移量 16 保存在虚表首部



> 派生类的虚表是如何排放的，这么放置有什么优点？
>
> - 由基类的虚表按顺序堆叠而成
> - 派生类新添加的虚函数指针会追加在第一个虚表后面



> 为什么不在内存位置直接存放派生类虚函数地址，而是存放 thunk 指令？
>
> - 主要目的是为了更新 this 指针
> - 试想 `Derive::func3` 内调用了某个非虚成员函数 `Derive::xxx` 
>     - 如果 this 指针不更新，基类的指针压根就找不到这个函数，会导致调用失败
>     - this 指针更新为派生类指针，调用就完全没有问题



## 虚析构函数

注意：在非虚继承场景中，complete object destructor == base object destructor

虚表里面有两个析构函数有点奇怪：

- 第一个 `[2]: 0x400f64 <Derive::~Derive()>` 是 complete object destructor 析构函数
- 第二个 `[3]: 0x400fe0 <Derive::~Derive()>` 是 deleting object destructor 析构函数



### base object destructor

通常情况下负责：

- 执行本类析构函数 `Derived::~Derived()` 中内容
- 调用基类 base object destructor 析构函数 `Base3::~Base3()` `Base2::~Base2()`

```assembly
Derived::~Derived() [base object destructor]:
    ...
    # 执行析构函数中内容
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    ...
    # 调用基类析构函数 base object destructor
    call    Base3::~Base3() [base object destructor]
    call    Base2::~Base2() [base object destructor]
```



### deleting object destructor

当释放对象时，会从类的 deleting object destructor 析构函数入口，基类/成员对象属性的释放不会执行，永远只负责两块内容：

- 调用当前类的 base object destructor 或 complete object destructor 触发析构链
- 执行 `operator delete()` 释放对象内存空间



```assembly
Derived::~Derived() [deleting destructor]:
    ...
    # 调用析构函数
    # 实际上调用的是 base object destructor
    call    Derived::~Derived() [complete object destructor]
    ...
    # 释放对象内存空间
    call    operator delete(void*, unsigned long)
```



# type-info

type-info，_ZTI 结构

- 前 8 个字节：指向 `__cxxabiv1::__class_type_info` 或 `__cxxabiv1::__vmi_class_type_info`
- 剩余条目：
    - 首条目：指向当前类的类名（_ZTS）+ ？？？？
    - 第一个条目：成员对象 1 的 type-info + ？？？
    - ...
    - 第 n 个条目：成员对象 n 的 type-info + ？？？



> 每个条目的后 8 个字节是什么意思？？？？？？？？
>
> - `0x4012f0 <_ZTI6Derive+8>:       0x0000000000401320      0x0000000200000000`
> - `0x401300 <_ZTI6Derive+24>:      0x0000000000401340      0x0000000000000002`
> - `0x401310 <_ZTI6Derive+40>:      0x0000000000401328      0x0000000000001002`



# type-string

_ZTS 保存的是类的名字





# 对象内存布局

单继承 Base、Derive 类

```bash
base vptr
base data
derived data
```

多继承 Base1、Base2、Derive 类

```bash
base1 vptr
base1 data
base2 vptr
base2 data
derived data
```

菱形继承Base、Base2、Base3、Derive 类

```bash
# Base 非虚, Base2、Base3 包含虚函数
base2 vptr
base data
base2 data
base3 vptr
base data
base3 data
derived data
# Base 包含虚函数
base vptr
base data
base2 data
base vptr
base data
base3 data
derived data
```



# 构造与析构

base object destructor

complete object destructor

deleting object  destructor



base object constructor

complete object constructor

没有与 deleting object  destructor 对应的 destructor，是直接展开的

```cpp
mov     edi, 56
call    operator new(unsigned long)
mov     rbx, rax
pxor    xmm0, xmm0
movups  XMMWORD PTR [rbx], xmm0
movups  XMMWORD PTR [rbx+16], xmm0
movups  XMMWORD PTR [rbx+32], xmm0
movq    QWORD PTR [rbx+48], xmm0
mov     rdi, rbx
call    Derive::Derive() [complete object constructor]
mov     QWORD PTR [rbp-24], rbx
```







# 多态调用过程

构造函数除了构造对象外，还需要设置构造出来的对象指向正确的虚表

析构函数在执行前，会恢复对象的虚表

this 指针的偏移也是重头戏！！！！



```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base_data = 0x11;
};

class Base2 : public Base {
public:
    virtual ~Base2() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base2_data = 0x21;
};

class Base3 : public Base {
public:
    virtual ~Base3() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base2_data = 0x31;
};

class Derive : public Base2, public Base3 {
public:
    virtual ~Derive() { std::cout << __FUNCTION__ << std::endl; }
    long long m_derive_data = 0x41;
};

int main() {
    Base3 *b3 = new Derive();
    delete b3;
    return 0;
}
```



```assembly
vtable for Derive:
    .quad   0
    .quad   typeinfo for Derive
    .quad   Derive::~Derive() [complete object destructor]
    .quad   Derive::~Derive() [deleting destructor]
    .quad   -24
    .quad   typeinfo for Derive
    .quad   non-virtual thunk to Derive::~Derive() [complete object destructor]
    .quad   non-virtual thunk to Derive::~Derive() [deleting destructor]
vtable for Base3:
    .quad   0
    .quad   typeinfo for Base3
    .quad   Base3::~Base3() [complete object destructor]
    .quad   Base3::~Base3() [deleting destructor]
vtable for Base2:
    .quad   0
    .quad   typeinfo for Base2
    .quad   Base2::~Base2() [complete object destructor]
    .quad   Base2::~Base2() [deleting destructor]
vtable for Base:
    .quad   0
    .quad   typeinfo for Base
    .quad   Base::~Base() [complete object destructor]
    .quad   Base::~Base() [deleting destructor]
typeinfo for Derive:
    .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
    .quad   typeinfo name for Derive
    .long   1
    .long   2
    .quad   typeinfo for Base2
    .quad   2
    .quad   typeinfo for Base3
    .quad   6146
typeinfo name for Derive:
    .string "6Derive"
typeinfo for Base3:
    .quad   vtable for __cxxabiv1::__si_class_type_info+16
    .quad   typeinfo name for Base3
    .quad   typeinfo for Base
typeinfo name for Base3:
    .string "5Base3"
typeinfo for Base2:
    .quad   vtable for __cxxabiv1::__si_class_type_info+16
    .quad   typeinfo name for Base2
    .quad   typeinfo for Base
typeinfo name for Base2:
    .string "5Base2"
typeinfo for Base:
    .quad   vtable for __cxxabiv1::__class_type_info+16
    .quad   typeinfo name for Base
typeinfo name for Base:
    .string "4Base"
```



执行 `Base3 deleting destructor`

```assembly
.L15:
    mov     QWORD PTR [rbp-24], rax
    mov     rax, QWORD PTR [rbp-24]
    test    rax, rax
    je      .L16
    mov     rdx, QWORD PTR [rax]
    add     rdx, 8
    mov     rdx, QWORD PTR [rdx]
    mov     rdi, rax
    call    rdx
```



注意：`Base2 b2 = new Derive()` 时，不涉及 non-virtual thunk

```assembly
non-virtual thunk to Derive::~Derive() [deleting destructor]:
    sub     rdi, 24
    jmp     .LTHUNK1
```



```assembly
Derive::~Derive() [deleting destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    Derive::~Derive() [complete object destructor]
    mov     rax, QWORD PTR [rbp-8]
    mov     esi, 56
    mov     rdi, rax
    call    operator delete(void*, unsigned long)
    leave
    ret
```



```assembly
Derive::~Derive() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Derive+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     edx, OFFSET FLAT:vtable for Derive+48
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax+24], rdx
    mov     esi, OFFSET FLAT:.LC3
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     rax, QWORD PTR [rbp-8]
    add     rax, 24
    mov     rdi, rax
    call    Base3::~Base3() [base object destructor]
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    Base2::~Base2() [base object destructor]
    nop
    leave
    ret
```



```assembly
Base3::~Base3() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base3+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     esi, OFFSET FLAT:.LC2
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    Base::~Base() [base object destructor]
    nop
    leave
    ret
```



```assembly
Base2::~Base2() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base2+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     esi, OFFSET FLAT:.LC1
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    Base::~Base() [base object destructor]
    nop
    leave
    ret
```



```assembly
Base::~Base() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     esi, OFFSET FLAT:.LC0
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char>...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char>...
    nop
    leave
    ret
```





# 多态触发

## 构造 & 析构

构造函数、析构函数中不会触发多态！！！

- 无论是构造函数，还是析构函数，第一件做的事都是修改虚指针！

- 遇到虚函数，不会根据虚指针查虚表（自己刚设置，查什么查），直接根据偏移量执行函数



虚表指针只会在构造和析构的过程中修改。



虚指针是如何一步步构造起来的，又是如何销毁的。

```assembly
; cons 会导致汇编代码不正常显示？
Base::Base() [base object ctor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    Base::func()
    nop
    leave
    ret
```



```assembly
Base::~Base() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    nop
    pop     rbp
    ret
```



> 构造函数不能触发多态：这 一似 乎 反 直 觉 的 行 为 有 个 好 理 由 。 由 于 b a s e c l a s s 构 造 函 数 的 执 行 更 早 于 d e r i v e d c l a s s 构 造 函 数 ，当 b a s e c l a s s 构 造 函 数 执 行 时 d e r i v e d c l a s s 的 成 员 变 量 尚 未 初 始化。如果此期间调用的virtual 函数下降至derivedclasses阶层，要知道derivedclass 的函数几乎必然取用local 成员变量，而那些成员变量尚未初始化。这将是 一张通往 不明确行为和彻夜调试大会串的直达车票。“要求使用对象内部尚未初始化的成分” 是危险的代名词，所以C++ 不让你走这条路
>
> 
>
> 析构函数不能触发多态：也类似，当析构基类对象时，派生类部分已经销毁了



## 普通成员函数



普通成员函数调用是会触发多态的！！！

- 普通成员函数中是不会动虚表指针的

```assembly
Base::func():
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi

    mov     rax, QWORD PTR [rbp-8]			;触发多态
    mov     rax, QWORD PTR [rax]
    add     rax, 8
    mov     rdx, QWORD PTR [rax]
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax
    call    rdx
    nop
    leave
    ret
```



## 练习

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void func() { xxx(); }

    virtual void xxx() {
        cout << "Base::xxx" << endl;
    }
    virtual ~Base() { func(); }
};

class Derive : public Base {
public:
    void xxx() override {
        cout << "Derive::xxx" << endl;
    }

};

int main() {
    Base *b = new Derive();
    b->func();		//Derive::xxx
    delete b;		//Base::xxx，析构函数修改虚指针了
    return 0;
}
```



# 问题

> 构造函数可以为虚函数吗？
>
> - 不可以，基类构造函数执行的时候，派生类部分还没有进行初始化



> 静态成员函数可以为虚函数吗？
>
> - 不可以，静态成员函数没有 this 指针，自然也就找不到虚指针，也就找不到虚表了。



# 参考

[gdb分析C++对象内存布局(一)](https://zhuanlan.zhihu.com/p/90726313)

[gdb分析C++对象内存布局(二)](https://zhuanlan.zhihu.com/p/90770282)

[深入探索 C++ 多态 ① - 虚函数调用链路](https://zhuanlan.zhihu.com/p/652005053)

[C++进行虚继承时为什么要新建虚函数表？](https://www.zhihu.com/question/528374835)

[What is the VTT for a class?](https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class)

[第17篇:C++继承中虚表的内存布局](https://zhuanlan.zhihu.com/p/190169823)

[gdb获取C++类成员函数地址](https://www.cnblogs.com/yang5sui/p/16873947.html)

[C++底层原理探究（C++对象模型一）](https://mp.weixin.qq.com/s?__biz=MzI3MDQyMDE2OQ==&mid=2247484793&idx=1&sn=2426cf693ca1b00ace99888e08939b7e&chksm=ead014dfdda79dc9a800e1de2404d94914b6f11d14739877c0a6c3197a16a0b196817b69e6a5&scene=21#wechat_redirect)

[C++底层原理探究（C++对象模型二）](https://mp.weixin.qq.com/s?__biz=MzI3MDQyMDE2OQ==&mid=2247484831&idx=1&sn=e6390784fa4aa2e6c0fb82063d8c6536&chksm=ead01439dda79d2feeee684026bb773c68460d74b3f447a0b13289f1066b5c69cfb4479a2ae7&scene=21#wechat_redirect)





