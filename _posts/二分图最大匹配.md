# 最大匹配

## 匈牙利算法

（Hungarian Algorithm）

### 原理

**大白话版** 

在寻找 u 的匹配时

- 如果 v 还没有匹配给其它人，则将其匹配给 u
- 如果 v 已经匹配给其它人 x 了，则询问 x 能不能重新寻找匹配：
    - 如果 x 找到了新的匹配，则将 v 匹配给 u
    - 如果 x 没有找到新的匹配，则无法将 v 匹配给 u
- 如果无法将 v 匹配给 u，则尝试下一个 v 进行匹配
- 最终都没匹配到任何 v，则说明无法匹配



先匹配的人：

- 具有优先匹配权，一旦匹配成功，则至少有一个匹配
- 但与后匹配的人发生冲突时，需要让出自己当前匹配

后匹配的人：

- 没有优先匹配权
- 但与先匹配的人发生冲突时，有权使其让出自己的匹配



**抽象版**

不断地寻找增广路，来增加匹配边，当找不到增广路时，达到最大匹配。



### 实现

```cpp
class Hungarian {
private:
    // 左侧集合元素个数，
    int m;
    // 右侧集合元素个数
    int n;
    // 从左侧集合到右侧集合的图
    // u = 1, v = 1, 并非说明 1 号节点形成自环
    // 而是说左侧的 1 号节点指向右侧的 1 号节点
    vector<vector<int>> g;
    // 记录右侧元素所匹配的左侧元素
    vector<int> match;
public:
    Hungarian(int m, int n, vector<vector<int>> &g) {
        this->m = m;
        this->n = n;
        this->g = g;
        match = vector<int>(n, -1);
    }
    int hungarian() {
        int res = 0;
        // 遍历左侧元素，为每个元素 u 寻找配偶
        // 但记录的时候是反着记的 match[v] = u
        for(int u = 0; u < m; ++u) {
            //vis[v] == 1 有两层含义
            // v 已经被假设匹配出去了
            // v 无法再更换匹配
            vector<int> vis(n);
            //i 表示左侧的未匹配点
            if(dfs(u, vis)) {
                res++;
            }
        }
        return res;
    }
private:
    bool dfs(int u, vector<int> &vis) {
        for(int v : g[u]) {
            if(vis[v]) continue;
            vis[v] = 1;
            //match[v] == -1 意味着：找到了增广路径的终点（另一个未匹配点）
            //dfs(match[v], vis)意味着：走匹配边
            //for(int v : g[u]) 为什么意味着走非匹配边？：因为 u 是从匹配边过来的，从 u 出发的匹配边只有一条，它回不去
            
            //如果 v 还没有匹配，直接把 v 匹配给 u
            //如果 v 已经匹配了，那就尝试让 match[v] 更换匹配
            //- 如果更换成功，也是可以把 v 匹配给 u 的
            //- 如果更换失败，则 v 无法匹配给 u，尝试下一个 v 能否匹配
            if(match[v] == -1 || dfs(match[v], vis)) {
                match[v] = u;
                return true;
            }
            //为什么这里不需要回溯
            //在 u 选择 v1 的情况下，match[v1] 无法更换匹配
            //在 u 选择 v2 的情况下
            //- match[v2] 选择更换 v3 v4 v5 都不成功没什么问题
            //- 但 match[v2] 不是也可以选择 v1，它就一定失败吗？
            //当然是失败的，问题不就又回到让 match[v1] 更换匹配么，之前不是试了，不行啊
            //即一旦 v 确定，dfs(match[v], vis) 就是确定的，只需要跑一遍就可以了
            //vis[v] = 0;
        }
        //所有 v 都尝试完成后，依旧无法匹配，则说明该 u 无法匹配
        return false;
    }
};
```



> 看实现，就是贪心，没看出来跟增广路有什么关系。。。。。。以上代码如何从增广路角度来理解？？？？？
>
> 



> vis 数组含义是什么，为什么在 bfs 时不需要回溯？？？？



### 复杂度



## 网络最大流

### 原理

将源点连上左边所有点，右边所有点连上汇点，容量皆为 1



# 最大权匹配



## 匈牙利算法

### 原理

通过一下两点，将问题转化为 n 对节点的 **最大权完美匹配**

- 左右两侧集合中元素个数一般不同，少的节点补充与多的一样
- 未出现的边的权重统一设置为 0 



## 动态匈牙利算法



## 费用流模型







# 练习



[洛谷 P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

[CodeForces Round 113 Div2 D. Shoe Store](https://codeforces.com/contest/166/problem/D)



# 参考

[算法学习笔记(5)：匈牙利算法](https://zhuanlan.zhihu.com/p/96229700)