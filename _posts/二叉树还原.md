# 二叉树还原

二叉树还原

- 先序遍历 + 中序遍历，可以唯一确定一颗二叉树 
- 中序遍历 + 后序遍历，可以唯一确定一颗二叉树 
- 先序遍历 + 后序遍历，不 能唯一确定一颗二叉树 



# 先序 + 中序

```cpp
//先序遍历的第一个元素为根节点
TreeNode *recover(const vector<int> &pre, int pp, int pr, const vector<int> &in, int ip, int ir) {
    if(pp > pr) return nullptr;
    TreeNode * root = new TreeNode(pre[pp]);
    if(pp == pr) return root;
    for(int i = ip; i <= ir; ++i) {
        if(in[i] == pre[pp]) {
            //left: i - ip, right: ir - i
            root->left = recover(pre, pp + 1, pp + i - ip, in, ip, i - 1);
            root->right = recover(pre, pp + i - ip + 1, pr, in, i + 1, ir);
            break;
        }
    }
    
    return root;
}
```



# 后序 + 中序

```cpp
//后续遍历的最后一个元素为根节点
TreeNode *recover(const vector<int> &post, int pp, int pr, const vector<int> &in, int ip, int ir) {
    if(pp > pr) return nullptr;
    TreeNode * root = new TreeNode(post[pr]);
    if(pp == pr) return root;
    for(int i = ip; i <= ir; ++i) {
        if(in[i] == post[pr]) {
            //left: i - ip, right: ir - i
            root->left = recover(post, pp, pp + i - ip - 1, in, ip, i - 1);
            root->right = recover(post, pp + i - ip, pr - 1, in, i + 1, ir);
            break;
        }
    }
    
    return root;
}
```



# 练习

[LeetCode 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[LeetCode 106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

