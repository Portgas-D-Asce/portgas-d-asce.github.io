C的运算符有以下几类：

- 算术运算符：`*`  `-`  `+`  `/`  `%`  `++`  `--`
- 关系运算符： `>`  `<`  `==`  `!=`  `>=`  `<=`
- 逻辑运算符：`!`  `&&`  `||`
- 位运算符：`<<`  `>>`  `~`  `|`  `^`  `&`
- 赋值运算符：`=`  `*=`  `-=`  `+=`  `/=`  `%=`
- 条件运算符：`?:`
- 逗号运算符：`,`
- 指针运算符：`*`  `&`
- 求字节数运算符：`sizeof`
- 强制类型转换运算符：`(类型)`
- 成员访问运算符：`.`  `.*`  `->`
- 下标运算符：`[]`
- 函数调用运算符：`()`
- typeof



---



C++ 扩展运算符

- 作用域运算符：`::`
- 类型转换运算符：`type()`  `static_cast`  `dynamic_cast`  `const_cast`  `reinterpret_cast`
- 内存管理运算符：`new`  `new[]`  `delete`  `delete[]`
- 输入输出运算符：`<<`  `>>`
- typeid



# 类型转换运算符

许多程序员相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一 种类型。这是错误的观念。任何 一个类型转换(不论是通过转型操作而进行的显式 转换，或通过编译器完成的隐式转换)往往真的令编译器编译出运行期间执行的码。 例如在这段程序中

## const_cast

通常被用来移除对象的常量性



## dynamic_cast

主要用来执行 安全向下转型



## reinterpret_cast



## static_cast



# operator new & operator delete

`operato new`  运算符有三种形式

```cpp
// throwing (1)	
void* operator new (std::size_t size);
// nothrow (2)	
void* operator new (std::size_t size, const std::nothrow_t& nothrow_value) noexcept;
// placement (3)	
void* operator new (std::size_t size, void* ptr) noexcept;
```



Default *allocation functions* (single-object form).

- (1) throwing allocation

    Allocates size bytes of storage, suitably aligned to represent any object of that size, and returns a non-null pointer to the first byte of this block. On failure, it throws a [bad_alloc](https://cplusplus.com/bad_alloc) exception. 

- (2) nothrow allocation

    Same as above *(1)*, except that on failure it returns a *null pointer* instead of throwing an exception. C++98C++11The default definition allocates memory by calling the the first version: `::operator new (size)`. If replaced, both the first and second versions shall return pointers with identical properties. 

- (3) placement

    Simply returns ptr (no storage is allocated). Notice though that, if the function is called by a *new-expression*, the proper initialization will be performed (for class objects, this includes calling its default constructor).



```cpp
// allocates memory by calling: operator new (sizeof(MyClass))
// but does not call MyClass's constructor
MyClass * p3 = (MyClass*) ::operator new (sizeof(MyClass));
```





```cpp
ordinary (1)	
void operator delete (void* ptr) noexcept;
nothrow (2)	
void operator delete (void* ptr, const std::nothrow_t& nothrow_constant) noexcept;
placement (3)	
void operator delete (void* ptr, void* voidptr2) noexcept;
```

Default *deallocation functions* (single-object form).

- (1) ordinary delete

    Deallocates the memory block pointed by ptr (if not null), releasing the storage space previously allocated to it by a call to [operator new](https://cplusplus.com/operator new)and rendering that pointer location invalid. 

- (2) nothrow delete

    Same as above *(1)*. The default definition calls the first version *(1)*: `::operator delete(ptr)`. 

- (3) placement delete

    Does nothing.



# operator new[] & operator delete[]



# 



# malloc/free



# new/delete

## new & delete

`new A`：会调用 `operator new(size_t)` 运算符，然后再调用构造函数



`delete：` 会先调用析构函数，然后调用 `operator delete(void *ptr)` 运算符

## new [] & delete []

`new[]`：会调用 `operator new[](size_t)` 运算符，然后逐对象依次调用构造函数



`delete[]`：逐对象依次调用析构函数，然后调用 `operator delete[](void *ptr)` 运算符

```cpp
A * x = new A[2]{{}, {}, {}, {}};

delete[] x;
```

`delete` 不用传递大小，因为大小就是类对象大小。

 `delete []` 时为什么不用传递数组长度？每个块都有一个头部信息，里面记录着块大小。

## placement new

`new (ptr)A` 称为 `placement new expression`，会先调用 `operator new(unsigned long, void*)` ，然后再调用构造函数。

也就是在已有空间上调用构造对象，可以是堆空间，也可以是栈空间。

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << "A's constructor" << endl;
    }

    ~A() {
        cout << "A's destructor" << endl;
    }

    void show() {
        cout << "num:" << num << endl;
    }
private:
    int num;
};

int main() {
    int mem[100];
    cout << (void*)mem << endl;
    A* p = new (mem)A;
    cout << p << endl;
    p->show();
    // delete (ptr)A 这种 placement delete expression 是不存在的
    // 直接调用析构函数
    p->~A();
}
```



## placement new []

```cpp
A *p = new (ptr)A[10];
for(int i = 0; i < 10; ++i) {
    p->~A();
    p++;
}
```

