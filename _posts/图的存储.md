图的存储：

- 邻接矩阵
- 邻接链表
- 链式前向星



# 邻接矩阵

优点：

- 常数时间内获取边的权重/判断边存在不存在

缺点：

- 存储空间大



用来存储稠密图较合适，稀疏图空间利用率低





# 邻接链表

优点：灵活，用来存储稀疏图更佳。



# 链式前向星



## 前向星

对所有边进行排序：优先按照起点排序，其次再按照终点排序



适合用来存储静态图



### 原理

两个数组：

- head[i]：表示以 i 为起点的第一条边
- len[i]：表示以 i 为起点的边的条数



### 遍历

```cpp
//u
for(int i = head[u]; i < head[u] + len[u]; ++i) {
    //int u = edges[i][0];
    int v = edges[i][1];
    int w = edges[i][2];
}
```





## 链式前向星

前向星存在的问题：

- 需要对边进行排序
- 插入新边不方便



### 原理

链式前向星进行了改造：

- head[i]：存储以 i 为起点的边的链表的头索引，初始值为 -1
- Edge：
    - To: 表示终点
    - w：表示权重
    - next：同起点的下一条边

```cpp
class Edge {
    int to; 	//终点
    int w;  	//权重
    int next; 	//同起点的下一条边
}
```



### 存储

图的边通常是以以下结构给出的：

```cpp
vector<vector<int>> edges(n, vector<int>(3));
vector<int> edge(3);
u = edge[0];
v = edge[1];
w = edge[2];
```

当构造链式前向星边的时候：

- 起点 u 已经没有存在的必要了
- 完全可以使用 u 的位置来存储 next
- 省去了结构体的定义，也没有额外再新申请空间构造边



### 添加边

```cpp
//u, v, w
vector<int> edge = {head[u], v, w};
head[u] = edges.size();
edges.push_back(edge);
```



### 遍历

```cpp
//u
int idx = head[u];
while(idx != -1) {
    int v = edge[idx][1];
    int w = edge[idx][2];
    
    idx = edge[idx][0];
}
```



# 常见问题

## 存不存在

判断某条边是否存在，存在的话，边的权重是多少？对于这种场景：

- 稠密图用邻接矩阵
- 稀疏图用 “single map”
    - key：64 字节，前 32 个字节存储行，后 32 个字节存储列。pair 也是可以的，但效率略低吧。
    - value：结构任意，可用来存储权重等信息
