---
layout: page
tags: 数据结构与算法 图论
image: /assets/image/21.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 迪杰斯特拉（Dijkstra）
---

# Dijkstra

## 原理
求解带权有向图的单源最短路径问题，要求权重值非负。算法步骤：
- **开集合：** 还未找到最短路径的节点的集合；
- **闭集合：** 已经找到最短路径的节点的集合；
- 不断地从开集合中取出距离起点最近的点，将其加入到闭集合当中，并对与该点相邻的点进行松弛操作。

## 实现
```cpp
vector<int> dijkstra(const vector<vector<pair<int, int>>> &g, int s) {
    int n = g.size();
    vector<int> dist(n, INT_MAX);
    dist[s] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({dist[s], s});
    while(!pq.empty()) {
        //不要用引用，pop 之后引用是未定义的
        auto [d, u] = pq.top();
        pq.pop();

        //可以使用 visited 数组，用于标记已经找到最短路径的节点
        //这里使用小优化，去掉了 visited 数组
        if(d > dist[u]) continue;
        for(auto [v, w] : g[u]) {
            int temp = d + w;
            if(temp < dist[v]) {
                dist[v] = temp;
                //松弛只是将新结果 push 到优先队列中，并没有移除之前结果
                pq.push({temp, v});
            }
        }
    }
    return dist;
}
```

## 复杂度

时间复杂度：$O(ElogV)$

空间复杂度：$O(E)$

## 思考

节点松弛操作，只是向优先队列中插入新的最短距离，而被替代的旧最短距离并未被删除，这样是否会导致优先队列中的元素越来越多，最终导致效率低下？
- 不会，松弛是按边松弛的， 松弛次数 < 边的条数
- 当弹出旧的最短距离时，此时松弛是没有意义的，借助于 $d > dist[u]$ （也就是 $visited$ 标记数组），直接跳过避免不必要的松弛操作


贪心的正确性：
- 贪心策略：每次从优先队列中弹出距离起点距离最小的节点，将其加入闭集合（该节点到起点的最短距离已计算完毕）
- 正确性：当前节点距离起点的距离已经是最小值（其他节点距离起点的距离大于该值）+ 变的权重为正数，这意味着当前节点无法被其他节点松弛，也就是说当前节点的最短距离已找到
- 这也正是算法要求边权重为正数的原因




# 最短路径打印
$dijkstra$ 只是计算出了最短距离，如何输出最短路径呢（任意一条即可）

## 关键点

在松弛的时候，记录是 “谁松弛了谁“ 这层关系（也就是最短路径上的前一个节点）

## 实现

```cpp
vector<pair<int, int>> dijkstra(const vector<vector<pair<int, int>>> &g, int s) {
    int n = g.size();

    //记录最短距离
    vector<int> dist(n, INT_MAX);
    dist[s] = 0;
    
    //记录最短路径前一个节点
    vector<int> pre(n, -1);
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({dist[s], s});
    while(!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if(d > dist[u]) continue;
        for(auto [v, w] : g[u]) {
            int temp = d + w;
            if(temp < dist[v]) {
                dist[v] = temp;
                pre[v] = u;
                pq.push({temp, v});
            }
        }
    }
    return dist;
}

vector<int> recover(const vector<int> &pre, int e) {
    vector<int> path;
    while(e != -1) {
        path.push_back(e);
        //指向前一个节点
        e = pre[e];
    }
    //路径反转回来，从起点到终点
    reverse(path.begin(), path.end());
    return path;
}
```
## 练习





# 最短路径方案数
这次，既不求最短距离，也不还原最短路径，而是统计最短路径的条数！！！

关键词：最短路径、拓扑序、动态规划

## 动态规划

### 状态定义

$dp[u]$：从起点到达节点 $u$ 最短路径的方案数

### 状态转移

假设从 $u_i$ 都能以最短路径到达 $v$ ，则：
$$
dp[v] = \sum_{i = 0} ^{x} dp[u_i] 
$$


方案数计算：

- 新的最短距离 < 老的最短距离时：以老的最短距离作为最短路径统计的方案数作废，方案数重置为前一个节点的最短路径方案数
- 新的最短距离 = 老的最短距离时：前一个节点有多个，每个都能缓冲出当前的最短距离，方案数为多个节点的最短路径方案数之和

## 实现
```cpp
vector<int> dijkstra(const vector<vector<pair<int, int>>> &g, int s) {
    int n = g.size();

    //记录最短距离
    vector<int> dist(n, {INT_MAX, -1});
    dist[s] = 0;
    
    //记录最短路径方案数
    vector<int> cnt(n);
    cnt[0] = 1;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({dist[s], s});
    while(!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if(d > dist[u]) continue;
        for(auto [v, w] : mp[u]) {
            int temp = d + w;
            if(temp < dist[v]) {
                dist[v] = temp;
                cnt[v] = cnt[u];
                pq.push({temp, v});
            } else if(temp == dist[v]) {
                cnt[v] += cnt[u];
            }
        }
    }
    return cnt;
}
```

## 练习
[LeetCode 1976. 到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)

