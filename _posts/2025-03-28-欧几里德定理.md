---
layout: page
tags: 数论
image: /assets/image/13.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 欧几里德定理
categories: [计算机, 数据结构与算法]
---

# 欧几里德定理

**定理：** 若 $a \% b = c$, 则 $gcd(a, b) = gcd(b, c)$ 。

## 证明

设 $gcd(a, b) = x$ , 则有：

$$
a = m_1x
, 
b = n_1x
$$

设 $gcd(b, c) = y$ , 则有：

$$
b = m_2y, c = n_2y
$$

设 $a = kb + c$ ， 则有：

$$
\begin{aligned}
a & = kb + c\\
& = km_2y + n_2y\\
& = 
(km_2 + n_2)y
\end{aligned}
$$

该公式说明：$b$ 和 $c$ 的最大公约数 $y$，也是 $a$ 和 $b$ 的公约数，即 $y <= x$


$$
\begin{aligned}
c &= a - kb\\
& = 
m_1x - kn_1x \\
& = (m_1 - kn_1)x；
\end{aligned}
$$

该公式说明：$a$ 和 $b$ 的最大公约数 $x$，也是 $b$ 和 $c$ 的公约数，即 $x <= y$



故，$x == y$ ， 也就是：

$$
gcd(a, b) = gcd(b, c)
$$

证毕。



## 辗转相除法

辗转相除法：使用欧几里得定理，求两个数最大公约数的算法

最大公约数（Greatest Common Divisor）

```cpp
int gcd(int a, int b) {
    while(b) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

最小公倍数（Least Common Multiple）
```cpp
int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;
}
```



## 二进制 GCD

终止条件：当 `x = 0 或 y = 0` 时，`gcd(x, y) = x + y`

递归：

- `x`, `y` 均为偶数。对于这种情况，显然 `2` 是公约数之一，即 `gcd(x, y) = 2 * gcd(x / 2, y / 2)`
- `x`, `y` 中有且仅有一个偶数。不妨设 `x` 是偶数，那么显然 `gcd(x, y) = gcd(x / 2, y)`
- `x`, `y` 均为奇数。不妨设 `x > y`，那么有 `gcd(x, y) = gcd(x - y, y)`



证明：

设 且 ，先考虑证明 （即“更相减损术”）

，那么有 ，即证 

考虑反证法，假设 其中 ，再设

就有 ，那么 与  互质矛盾，得证 



# 扩展欧几里德定理



> 二元一次方程 $ax + by = d$ 存在整数解 $\Leftrightarrow$ $d$ 为 $gcd(a, b)$ 的倍数 



## 证明

### 充分性证明

> 若 $d$ 为 $gcd(a, b)$ 的倍数，则二元一次方程 $ax + by = d$​​ 存在整数解
>
> - 若 $ax + by = gcd(a, b)$ 有整数解，$ax + by = d$ 必有整数解
> - 因此，只证明 $ax + by = gcd(a, b)$ 有整数解



设：

$$
a = kb + c
$$

设 $(x_0$, $y_0)$ 是以下方程组的一组整数解

$$
bx + cy = gcd(b, c)
$$

则，有：

$$
\begin{aligned}
gcd(b, c) & = bx_0 + cy_0 \\
& = bx_0 + (a - kb)y_0 \\
& = ay_0 + b(x_0 - ky_0) \\
& = gcd(a, b)
\end{aligned}
$$

即 $(y_0, x_0 - ky_0)$ 是以下方程的一组整数解

$$
ax + by = gcd(a, b)
$$

也就是，若 $bx + cy = gcd(b, c)$ 存在一组整数解，那么 $ax + by = gcd(a, b)$ 也一定存在一组整数解



结合欧几里得定理：

$$
gcd(a, b) = gcd(b, c) = ... = gcd(gcd(a, b), 0)
$$

也就是说如果以下方程存在一组整数解，那么 $ax + by = gcd(a, b)$ 就一定存在一组整数解

$$
gcd(a, b)x + 0y = gcd(gcd(a, b), 0)\\
gcd(a, b)x = gcd(a, b)
$$

显然上述方程一定存在整数解 $(1, 0)$ （$y$ 任意，通常取 $0$），因此，$ax + by = gcd(a, b)$ 一定存在整数解

证毕。



### 必要性证明（反证法）

> 若二元一次方程 $ax + by = d$ 存在整数解，则 $d$ 为 $gcd(a, b)$ 的倍数

假设 $d$ 不为 $gcd(a, b)$ 的倍数，设：

$$
d = m * gcd(a, b) + d^{'}
$$

因为 $ax + by = d$ 有整数解，即以下方程有整数解：

$$
a / gcd(a, b) * x + b / gcd(a, b) * y = m + d^{'} / gcd(a, b)
$$

显然，$d^{'} / gcd(a, b)$ 不为整数，上述方程一定不成立，矛盾，故，假设不成立

证毕。



## 通解



对于以下方程，$(1, 0)$ 只是一个特解，通解为 $(1, y_{any})$

$$
gcd(a, b)x + 0y = gcd(gcd(a, b), 0)
$$

如何求以下方程的特解，通解呢？

$$
ax + by = m * gcd(a, b)
$$


若 $(x_0, y_0)$ 为 $ax + by = gcd(a, b)$ 的一个特解，其通解为：

$$
\begin{cases}
x = x_0 + (b\ /\ gcd(a, b))\ *\ t \\
y = y_0 - (a\ /\ gcd(a, b))\ *\ t \\
\end{cases}
$$



## 实现

```cpp
void exgcd(int a, int b, int &x, int &y) {
    if(b = 0) {
        x = 1;
        y = 0;
        return;
    }
    // 求解与证明是反着来的
    extended_euclidean(b, a % b, y, x);
    y -= a / b * x;
}
```



```cpp
// ax + by = gcd(a, b)
pair<long long, long long> exgcd(long long a, long long b) {
    if(b == 0) return {1, 0};
    auto [x, y] = exgcd(b, a % b);
    return {y, x - a / b * y};
}
```





# 练习

[LeetCode 365. Water and Jug Problem](https://leetcode.com/problems/water-and-jug-problem/submissions/)



