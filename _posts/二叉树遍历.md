# 节点

```cpp
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```



# 遍历

二叉树遍历

- 先序遍历：根--左--右
- 中序遍历：左--根--右
- 后序遍历：左--右--根
- 层序遍历：从上到下，从左到右



## 通用版

递归

```cpp
void travel(TreeNode* node) {
	if(!node) return;
    //pre_order
    //cout << node->val << endl;
    
	inorder_recursion(node->left);
    
    //in_order
	//cout << node->val << endl;
    
	inorder_recursion(node->right);
    
    //post_order
    //cout << node->val << endl;
}
```

迭代

```cpp
vector<int> travel(TreeNode* root) {
    vector<int> res;
    stack<pair<TreeNode *, int>> stk;
    if(root) stk.push({root, 0});
    while(!stk.empty()) {
        auto [cur, flag]= stk.top();
        stk.pop();
        if(flag == 1) {
            res.push_back(cur->val);
        } else {
            //post_order
            //stk.push({cur, 1});
            
            //put right subtree firstly
            if(cur->right) stk.push({cur->right, 0});
            
            //inorder
            stk.push({cur, 1});
            
            if(cur->left) stk.push({cur->left, 0});
            
            //pre_order
            //stk.push({cur, 1});
        }
    }
    return res;
}
```



## 特化版

先序遍历

```cpp
vector<int> preorder(TreeNode* root) {
    if(!root) return {};

    vector<int> res;
    stack<TreeNode *> stk;
    stk.push(root);
    while(!stk.empty()) {
        TreeNode *cur = stk.top();
        stk.pop();
        res.push_back(cur->val);
        if(cur->right) stk.push(cur->right);
        if(cur->left) stk.push(cur->left);
    }
    return res;
}
```



后续遍历：左-右-中。

- 作弊方式：先中-右-左（类似于先序遍历），后 reverse。

```cpp
vector<int> postorder(TreeNode* root) {
    if(!root) return {};

    vector<int> res;
    stack<TreeNode *> stk;
    stk.push(root);
    while(!stk.empty()) {
        TreeNode *cur = stk.top();
        stk.pop();
        res.push_back(cur->val);
        //第一处不同点
        if(cur->left) stk.push(cur->left);
        if(cur->right) stk.push(cur->right);
    }
    //第二处不同点
    reverse(res.begin(), res.end());
    return res;
}
```



中序遍历

- 对于每个子树，总是先走到最左侧
- 到达最左侧后，再访问其父节点
- 访问完子树之后 root 节点必为 nullptr

```cpp
vector<int> inorder(TreeNode* root) {
    vector<int> res;
    stack<TreeNode *> stk;
    while(root || !stk.empty()) {
        //优先左子树
        while(root) {
            stk.push(root);
            root = root->left;
        }
        
        //回溯，访问父节点
        root = stk.top();
        stk.pop();
        res.push_back(root->val);

        //最后右子树
        root = root->right;
    }
    return res;
}
```



## 层序遍历

```cpp
void level_order(TreeNode* root) {
    if(!root) return;
    queue<TreeNode*> que;
    if(root) que.push(root);
	while(!que.empty()) {
		TreeNode* cur = que.front();
		que.pop();
        //cout << cur->val << endl;
		if(cur->left) que.push(cur->left);
		if(cur->right) que.push(cur->right);
	}
}

void line_print(TreeNode* root) {
	if(!root) return;
	queue<TreeNode*> que;
    que.push(root);
    while(!que.empty()) {
        int sz = q.size();
        //这个 sz 是优点意思的
        for(int i = 0; i < sz; ++i) {
            TreeNode *cur = que.front();
            que.pop();
            //cout << cur->val << "   ";
            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
        //cout << endl;
    }
}
```



## 练习

[LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

[LeetCode 144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

[LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

[LeetCode 589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

[LeetCode 590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

[LeetCode 102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)


