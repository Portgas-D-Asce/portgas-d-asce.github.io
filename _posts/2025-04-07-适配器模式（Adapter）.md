---
layout: page
image: /assets/image/46.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 适配器模式（Adapter）
categories: [计算机, 设计模式]
---

# 概述

就是把一个东西包装成另外一个东西，使其符合标准或用起来更方便等。典型的就是栈、队列，既可以用数组包装得到，也可以用链表包装得到。



## 动机

由于应该用环境的变化，常常需要将 “一些现存的对象” 放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。



如何应对这种 “迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？



## 定义

将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。





## 类图

![/assets/content/16.png](/assets/content/16.png)



# 实现

例子可能不太合适

```cpp
#include <iostream>
using namespace std;

class IAdaptee {
public:
    virtual ~IAdaptee() = default;
    virtual void func1() = 0;
    virtual void func2() = 0;
};

class Adaptee : public IAdaptee {
public:
    void func1() override {
        cout << "Adaptee func1" << endl;
    }

    void func2() override {
        cout << "Adaptee func2" << endl;
    }
};

class IAdapter {
protected:
    IAdaptee* _adaptee;
public:
    explicit IAdapter(IAdaptee* adaptee) : _adaptee(adaptee) {}
    virtual ~IAdapter() = default;

    virtual void process() = 0;
};

class Adapter : public IAdapter {
public:
    explicit Adapter(IAdaptee* adaptee) : IAdapter(adaptee) {}

    void process() override {
        cout << "Adapter process" << endl;
        _adaptee->func1();
        _adaptee->func2();
    }
};


int main() {
    Adaptee adaptee;
    Adapter adapter(&adaptee);
    adapter.process();

    return 0;
}
```





# 应用

Adapter 模式主要应用于 “希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用，类库迁移等方面非常有用



GoF 23 定义了两种 Adapter 模式的实现结构：对象适配器和类适配器。但类适配器采用 “多继承” 的实现方式，一般不推荐使用。对象适配器采用 “对象组合” 的方式，更符合松耦合精神。



Adapter 模式可以实现得非常灵活，不必拘泥上面定义的两种结构