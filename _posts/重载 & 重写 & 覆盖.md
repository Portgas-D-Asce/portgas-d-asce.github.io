# 重载（overload）

重载说的是：函数名相同，参数列表不同

- 返回值类型无法作为重载依据
- 底层 const 可以作为重载依据



```cpp
int add(int x, int y);
int add(int x, int y, int z);

void func(int *p) {}
void func(const int *p) {}

void draw_circle(int r = 0, int x = 0, int y = 0);
```



不构成重载

```cpp
int mul(int x, int y);
double mul(int x, int y);
```



重载可能会导致不可分辨错误

```cpp
int fa(int x);
int fa(float x);

double a = 5.56;
//编译器无法确定将 double 类型的 5.56 转换成 int 还是 float，导致不可分辨错误。
int b = fa(a);
```



# 重写（override）

重写是怎么回事呢：

- 派生类中重新实现基类的虚函数，返回值类型，参数个数、类型均要保持一样。

- 这么实现后，指向派生类的基类指针/引用调用虚函数时，访问的是派生类重写后的函数
- 派生类重写函数不用 virtual 修饰，而是使用 override 修饰即可



```cpp
class Base{
public:
    virtual int add(int a, int b);
};

class Derived :public Base {
public:
    virtual int add(int a, int b);
};
```



**协变：** 以下情况下派生类的这个虚函数也重写了基类类中的虚函数

- 派生类中的虚函数和基类中的虚函数，函数名、参数个数、参数类型都相同，只是返回值类型不同：
- 基类的虚函数返回基类的指针或者引用
- 派生类虚函数返回派生类的指针或者引用



```cpp
#include<iostream>
using namespace std;
class Person {
public:
    virtual  Person& BuyTickets() {
        cout<<"成人买票-全票"<<endl;
        return *this;
    }
public:
    string  _name;
};

class Student : public Person{
public:
    virtual Student& BuyTickets() {
        cout<<"学生买票-半票"<<endl;
        return *this;
    }
public:
    int _num ;
};

void Fun (Person* p) {
     p->BuyTickets();
}
void Fun (Person&p) {
     p.BuyTickets();
}   

int main() {
    Person p;
    Student s;
    Fun(p);
    Fun(s);

    Fun(&p);
    Fun(&s);
    return 0;
}
```



# 覆盖（Cover）

覆盖说的是这么一回事：

- 派生类中同名成员函数会隐藏基类中的同名成员函数，即派生类对象/指针无法直接调用基类的同名函数
- 如果确实想调用基类的同名函数，那么使用域运算符来访问 or 使用 using 重新导入

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void func() {
        cout << "empty func" << endl;
    }
    virtual void func (int x) {
        cout << "Base::func(int)" << endl;
    }
};

class Derive : public Base {
public:
    // using Base::func;
    void func(int x) override {
        cout << "Derive::func(int)" << endl;
    }
};

int main() {
    Derive d;
    //派生类重写 func(int) 隐藏了基类所有名为 func 函数
    //d.func();	
    //通过域运算符来访问
    d.Base::func();				
    d.func(1);
    return 0;
}
```
