# 方向数组

```cpp
// 8 方向
int dir[][2] = {-1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1};

// 4 方向

// 马走日

// 象走田
```



# 记忆化



# 离散化





# 离线化



# 状态压缩





# BFS/DFS



# 暴力枚举

## 排列型枚举

当求所有元素的排列结果时，并要求不重复时，可以使用 `next_permutation` 来获取所有排列



dfs + 回溯：枚举所有的排列结果。

- 可以对长度、是否重复进行约束。
- 使用这些约束进行剪枝。

时间复杂度 $n!$​

```cpp
vector<int> vis(n);
function<void(int)> dfs = [&](int x) {
    if(x == n) return;
    // 以第 i 个元素开始的排列
    for(int i = 0; i < n; ++i) {
        // 已经加入排列的无法重复加入
        if(vis[i]) continue;
        // 打上标记
        vis[i] = true;
        // 加入排列
        temp.push_back(s[i]);
        if(st.find(temp) == st.end()) {
            st.insert(temp);
            dfs(x + 1);
        }
        temp.pop_back();
        vis[i] = false;
    }
};
```



## 组合型枚举

可以使用状态压缩，来枚举所有组合



dfs + 回溯：枚举所有组合结果。

- 同样也可以对长度、是否重复进行约束。
- 使用这些约束进行剪枝。

时间复杂度 $2^n$

```cpp
```

