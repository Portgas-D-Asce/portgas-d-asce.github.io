---
layout: page
tags: 设计模式
image: /assets/image/32.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 工厂模式（Factory）
---

# 概述

## 动机

在软件系统中，经常面临着创建对象的工作;由于需求的变化， 需要创建的对象的具体类型经常变化。



如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧 耦合?



```cpp
class IProduct {
public:
    virtual ~IProduct() = default;
    virtual void func() = 0;
};

class Product1 : public IProduct {
public:
    void func() override {
        cout << "Product1" << endl;
    }
};

class Product2 : public IProduct {
public:
    void func() override {
        cout << "Product2" << endl;
    }
};

void test() {
    IProduct* pro = new Product1();
    // IProduct* pro = new Product2();
    pro->func();
}
```



无论是哪种选择，都会导致 test 函数强制依赖于某个具体的实现，一旦要切换到其它具体实现，必须修改代码。将 `pro` 以参数的形式传递进来就好了吧

```cpp
void test(IProduct* pro) {
    pro->func();
}
```

可以，test 函数现在只依赖于抽象，而不依赖于某个具体的实现。



> 为什么要有工厂？

- 但如果 test 实现内部还需要多个跟 pro 一样的实例怎么获得？？？
- 拷贝？？？我要的是原生的实例，你知道它们刚出生时长什么样子吗？？？
- 得了得了，把生产机器传给你总可以了吧，要多少个就自己生产多少个！！！



```cpp
void test(IProductFactory* factory) {
    IProduct* pro = factory->create();
}
```



IProductFactory 就是主角



## 定义

定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟(目的:解耦， 手段:虚函数)到子类



让当前模块摆脱具体依赖（new ...）

## 类图

![/assets/content/4.png](/assets/content/4.png)



# 实现

```cpp
#include <iostream>
using namespace std;

class IProduct {
public:
    virtual ~IProduct() = default;
    virtual void func() = 0;
};

class IFactory {
public:
    virtual ~IFactory() = default;
    virtual IProduct* create() = 0;
};

class Product1 : public IProduct {
public:
    void func() override {
        cout << "Product1" << endl;
    }
};

class FactoryProduct1 : public IFactory {
public:
    IProduct* create() override {
        return new Product1();
    }
};

class Product2 : public IProduct {
public:
    void func() override {
        cout << "Product2" << endl;
    }
};

class FactoryProduct2 : public IFactory {
public:
    IProduct* create() override {
        return new Product2();
    }
};

void test(IFactory* factory) {
    IProduct* pro1 = factory->create();
    pro1->func();

    IProduct* pro2 = factory->create();
    pro2->func();
}


int main() {
    IFactory* factory = new FactoryProduct2();
    test(factory);
    return 0;
}
```



test 模块摆脱了具体实现（new）的依赖，再也不用换个具体实现就要改代码了！！！



# 应用

工厂模式说白了，就是帮助某个模块摆脱具体依赖！！！！！！！

- 这个模块需要动态创建多个同种类型产品（如果不需要多个，就不用工厂了，直接用虚基类指针就行）
- 产品可以有不同的类型





Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。

Factory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展(而非更改)的策略，较好 地解决了这种紧耦合关系。

Factory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法/参数相同