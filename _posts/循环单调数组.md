# 旋转数组

## 实现

方案一优点：

- 线性时间复杂度，常数空间复杂度
- 仅要求单向迭代器，单链表都能反转（但是链表类型没有必要这么麻烦，直接添加新的，释放旧的）

```cpp
template <class FIterator>
void rotate(FIterator first, FIterator middle, FIterator last) {
    if(middle == last) return;
    FIterator next = middle;
    while(first != next) {
        swap(*first++, *next++);
        if(next == last) {
            next = middle;
        }
        else if(first == middle) {
            middle = next;
        }
    }
}
```



方案二也是一种蛮不错的选择，但要求双向迭代器

```cpp
template<typename BdIterator>
void rotate(BdIterator first, BdIterator middle, BdIterator last) {
    reverse(first, middle);
    reverse(middle, last);
    reverse(first, last);
}
```





## 练习

[LeetCode 189.轮转数组](https://leetcode.cn/problems/rotate-array/)







# 单调旋转数组

旋转单调数组：经若干次旋转，可变为非严格单调的数组，以单调递增为例：

- 最特殊情况：已经单调递增了
- 除了上述特殊情况外，该数组总是可以分为两个单调递增部分。



型如一下的数组称为循环单调数组

```bash
# 循环单调递增数组
# 严格
# 4 5 6 7 8 1 2
# 非严格
# 4 5 6 7 8 4 4
# 单调递增数组可被看成是特殊的循环单调递增数组
# 1 2 4 5 6 7 8

# 循环单调递减数组
# 严格
# 9 8 7 6 12 11
# 非严格
# 9 8 7 6 9 9
# 单调递减数组可被看成是特殊的循环单调递减数组
# 12 11 9 8 7 6

# 既是循环单调递增数组，也是循环单调递减数组
# 1 1 1 5 1 1 1 1
# 3 3 3 1 1 1 3 3 3
```



> 如何判断一个数组是不是循环单调数组？？？？





> 即是旋转单调递增数组也是旋转单调递减数组的条件
>
> - 只有一种数字
> - 只有两种数字，且两种数字都各自连续





## 实现

寻找旋转单调数组的 最小 or 最大值，也就是单调数组的入口



> 当 middle == last 时，无法确认 middle 处于单调递增 A 部分，还是处于单调递增 B 部分
>
> - 如果直接更新 first = middle + 1 ，当 middle 处于 B 部分时会跳过最小值
> - 如果直接更新 last = middle ，当 middle 处于 A 部分时会跳过最小值
> - 总之以上两种更新都不合适，但好在总是可以进行 last - 1！！！



> 返回值：
>
> - 仅当 *nums.begin() == mn 时，会返回 nums.begin()，最小值跨越了后缀和前缀
> - 其它情况均返回第一个 mn 的位置



```cpp
template<typename RaIterator, typename Compare = less<typename iterator_traits<RaIterator>::value_type>>
RaIterator rotate_monotony_header(RaIterator p, RaIterator r, Compare comp = Compare()) {
    if(p == r) return r;
    --r;
    while(p < r) {
        RaIterator q = p + ((r - p) >> 1);
        if(*q == *r) {
            --r;
        } else if(comp(*q, *r)) {
            r = q;
        } else {
            p = q + 1;
        }
    }
    return p;
}
```



在循环单调数组上查看目标值是否存在

```cpp
template<typename RaIterator, typename Compare = less<typename iterator_traits<RaIterator>::value_type>>
RaIterator rotate_monotony_find(RaIterator p, RaIterator r,
    	const typename iterator_traits<RaIterator>::value_type& tar,
    	Compare comp = Compare()) {
    if(p == r) return r;
    RaIterator end = r;
    --r;
    while(p < r) {
        RaIterator q = p + ((r - p) >> 1);
        if(*q == tar) return q;
        if(*q == *r) {
            --r;
        } else if(comp(*q, *r)) {
            if(tar > *q && tar <= *r) {
                first = q + 1;
            } else {
                last = q - 1;
            }
        } else {
            if(tar < *q && tar >= *p) {
                r = q - 1;
            } else {
                p = q + 1;
            }
        }
    }
    return *p == tar ? p : r;
}
```



## 练习

[CodeForces 913 F. Shift and Reverse](https://codeforces.com/contest/1907/problem/F)

[LeetCode 33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

[LeetCode 153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

[LeetCode 154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)