# const_cast

const_cast 用于移除 指针/引用 的底层 const

```cpp
int x = 10;
const int* ptr1 = &x;

// error
// int* ptr2 = ptr1;
int* ptr2 = const_cast<int*>(ptr1);

// error
// *ptr1 = 20;
*const_cast<int*>(ptr1) = 30;
```



```cpp
int x = 10;
const int& y = x;
// error
//int& z = y;
int& z = const_cast<int&>(y);
```



```cpp
class Base {
private:
    int x;
public:
    void func() const {
        //this->x++;
        const_cast<Base*>(this)->x++;
    }
};
```



# static_cast

隐式类型转换显式化，隐式类型转化一般是低风险类型转换

```cpp
double x = 10.5;
int y = x;
int z = static_cast<int>(x);
cout << y << " vs " << z << endl;
```



```cpp
class Base {
private:
    int x;
public:
    explicit operator int() const {
        return x;
    }
};

// error
// int x = Base();
int x = static_cast<int>(Base());
```



```cpp
class Base {};
class Derived : public Base {};

Base* ptr1 = new Derived();
Base* ptr2 = static_cast<Base*>(new Derived());

Derived d;
Base& b1 = d;
Base& b2 = static_cast<Base&>(d);
```



# dynamic_cast

RTTI，将基类指针转换为派生类指针（引用），要求基类具有虚表

```cpp
class Base {
public:
    virtual ~Base() = default;
};
class Derived : public Base {};

// error when no vtable
Derived d1;
Base& b = d1;
auto& d2 = dynamic_cast<Derived&>(b);
```



# reinterpret_cast

强制类型转换，用于风险较高的类型转换：不同类型的指针之间转换等。

```cpp
int x = -1;
char* ptr = reinterpret_cast<char*>(&x);
cout << *ptr << endl;
```

