# 问题描述

给定网络，指定源汇点，求最大流 f，该流的最大流量最大



# Ford-Fulkerson

## 原理

贪心地找从源点到汇点的路径，并更新残余流量，不断重复，直到找不到路径为止。



主要步骤：

- 从源点开始，找到达汇点的路径 $p$
- $p$ 上最小的流量作为该路径的流量 $x$
    - 将 $x$ 从路径上所有边中减去，边的残余容量为 0 时，删除该边
    - **为路径上所有边添加反向边**，容量为 $x$​。反向路径已存在则需要合并
    - 显然，正向边和反向边的权值之和，总等于边的起始容量
- 不断重复以上两步，直到找不到路径为止



> 为什么迭代会收敛到找不到路径？？？？
>
> - 迭代过程中：从源点出发的边的容量是不断减少的，进入汇点的边的容量是不断减少的
> - 上面说法可能不太具有说服力：迭代过程中，找到流的流量大小是不断增加了，而最大流不是无限大的，所以总是会结束



## 复杂度

时间复杂度：迭代次数 * 遍历复杂度

$O(f * m)$：$f$ 是最大流大小，$m$​ 是边的条数



## 问题

时间复杂度依赖于最大流的大小



# Edmonds-Karp

## 原理

Ford-Fulkerson 算法的改进：使用 BFS 算法寻找增广流，使得迭代次数与最大流大小无关。



## 复杂度

$O(m^2n)$最多迭代 $m * n$ 轮，每轮复杂度 $O(m)$

- $m$ 是边的条数
- $n$ 是节点个数



## 问题

> 迭代次数上界为 $O(mn)$ 证明？？？？
>
> 



# Dinic（重点）

## 原理

Ford-Fulkerson 和 Edmonds-Karp，每次迭代只能找到一条增广路，必须更新完剩余流量、添加完反向边后，才能开始下一轮迭代。



Dinic 算法的思想：

- 每次迭代寻找多条增广路，直到找到阻塞流之后，才结束本次迭代。
- 为了支持同时寻找多条增广路，引入了 $level \ graph$ 的概念。



阻塞流



level graph：层序遍历，将所有节点分层，仅保留不同层节点之间的边



算法迭代步骤：

- construct the level graph of the residual graph
- Find a block flow on the level graph
- Update. the residual graph: update weights, add backward edges



## 实现

```cpp
template<typename T>
class Dinic {
private:
    int n;
    int s;
    int t;
    
    // 链式前向星 edges 数组
    // {v, capacity, next}
    vector<vector<T>> edges;
    // 链式前向星 head 数组
    vector<int> head;
    
    vector<int> depth;
    vector<int> cur;
public:
    Dinic(int _n, int _s, int _t) {
        n = _n;
        s = _s;
        t = _t;

        // 从 2，3 开始，因为需要用标记 0 表示结束边
        edges.emplace_back(3);
        edges.emplace_back(3);

        head = vector<int>(n);
        depth = vector<int>(n);
        cur = vector<int>(n);
    }

    void add_edge(int u, int v, T capacity) {
        int idx = edges.size();
        edges.push_back({v, capacity, head[u]});
        head[u] = idx++;
        edges.push_back({u, 0, head[v]});
        head[v] = idx;
    }

    T max_flow(T init_val) {
        T flow = 0;
        while(bfs()) {
            // 重置 cur 数组
            cur = head;
            
            // 寻找阻塞流
            flow += dfs(s, init_val);
        }
        return flow;
    }
    
    vector<int> min_cut() const {
        vector<int> cut(n);
        queue<int> que;
        que.push(s);
        cut[s] = 1;
        while(!que.empty()) {
            int u = que.front();
            que.pop();
            for(int i = head[u]; i; i = edges[i][2]) {
                int v = edges[i][0];
                T capacity = edges[i][1];
                if(cut[v] != 0 && capacity) {
                    que.push(v);
                    cut[v] = 1;
                }
            }
        }
        return cut;
    }
private:
    bool bfs() {
        // 重置深度数组
        fill(depth.begin(), depth.end(), 0);
        
        queue<int> que;
        que.push(s);
        // 需要用状态 0 表示节点的深度还没有找到，源点深度从 1 开始
        depth[s] = 1;
        while(!que.empty()) {
            int u = que.front();
            que.pop();
            for(int i = head[u]; i; i = edges[i][2]) {
                int v = edges[i][0];
                T capacity = edges[i][1];
                if(depth[v] == 0 && capacity != 0) {
                    depth[v] = depth[u] + 1;
                    que.push(v);
                    // 一旦找到汇点，这里直接返回了
                    // 剩余未访问的点的深度 >= 汇点深度，遍历时不会用到
                    if(v == t) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    T dfs(int u, T mf) {
        // mf: 上游节点最多输送的流量
        if(u == t) {
            return mf;
        }

        // 从 u 节点出发，可以到达 t 的流量总和
        T sum = 0;
        for(int i = cur[u]; i; i = edges[i][2]) {
            // 当前弧优化，记录 u 找到哪条边了
            cur[u] = i;
            int v = edges[i][0];
            T capacity = edges[i][1];
            if(depth[v] == depth[u] + 1 && capacity) {
                // v 向 t 总共传输了多少流量
                T f = dfs(v, min(mf, capacity));

                // 剩余流量减去已传输流量
                edges[i][1] -= f;
                // 反向边加上已传输流量
                edges[i ^ 1][1] += f;

                // 累加 u 可以传输向 t 的流量
                sum += f;

                // 上游传递下来的流量还剩多少
                mf -= f;
                // 余量优化，没有剩余了直接退出
                if(!mf) {
                    break;
                }
            }
        }
        // 残枝优化
        // sum == 0 表示无法从 u 向 t 传递流量
        if(!sum) {
            depth[u] = 0;
        }
        return sum;
    }
};
```



三个重要的剪枝优化：

- **当前弧优化：** 当前节点之前边已经被分配过流量了，下次为该节点分配流量时不再（也不能）从第一条边开始，直接从当前边开始。
- **余量优化：** 一旦上游传递下来的流量用完了，则不再进行后续遍历，也就是剪枝。
- **残枝优化：** 流量向下传递过程中，最终却发现无法到达汇点，则通过修改节点深度，使得下次流量不再走该路径。



## 复杂度

$O(mn^2)$

最多迭代 $n - 1$ 轮，每轮迭代复杂度 $O(mn)$



## 问题

> 迭代轮数上限证明
>
> 



# 练习

[P3376 【模板】网络最大流](https://www.luogu.com.cn/problem/P3376)



# 参考

[【D21 网络流 最大流 Dinic 算法】](https://www.bilibili.com/video/BV18F411c7M1?vd_source=df7e68e4ec861c93992b5b71d7e56949)
