---
layout: page
tags: 设计模式
image: /assets/image/31.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 命令模式（Command）
categories: [aaa, bbb, ccc]
---

# 概述

## 动机

在软件构建过程中，“行为请求者” 与 “行为实现者” 通常呈现一种 “紧耦合”。但在某些场景：比如需要对行为进行 “记录、撤销、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。



在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为 对象，可以实现二者之间的松耦合



## 定义

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。



## 类图

![/assets/content/7.png](/assets/content/7.png)



命令模式就是把命令封装成一个个可调用对象，当需要执行某个命令的时候，只需要做两件事：

- 创建一个命令对象
- 调用（执行）这个命令对象



涉及角色：

- Receive：命令接收者，一个命令通常是由若干部门配合完成的，也就是有多个接收者，每人完成自己的部分，最终完成整个命令。
- Command：命令可调用对象，包含命令需要由哪些人配合，以及如何执行



# 类图



# 实现

```cpp
#include <iostream>
using namespace std;

class Receive1 {
public:
    void func() {
        cout << "Receive1 func" << endl;
    }
};

class Receive2 {
public:
    void func() {
        cout << "Receive2 func" << endl;
    }
};

class Command1 {
private:
    Receive1 _r1;
public:
    // 这个命令只要 Receive1 一个人就能完成
    Command1() : _r1(Receive1()) {}
    void operator()() {
        _r1.func();
    }
};

class Command2 {
private:
    Receive1 _r1;
    Receive2 _r2;
public:
    // 命令需要 Receive1 和 Receive2 配合完成
    Command2() : _r1(Receive1()), _r2(Receive2()) {}
    void operator()() {
        _r1.func();
        _r2.func();
    }
};


int main() {
    // 创建一个 Command1 命令
    Command1 c1;
    // 执行命令
    c1();

    // 创建一个 Command2 命令
    Command2 c2;
    // 执行命令
    c2();

    return 0;
}
```

```cpp
class ICommand {
public:
    virtual ~ICommand() = default;
    virtual void execute() = 0;
};

class Command1 : public ICommand {
private:
    int _x;
public:
    explicit Command1(int x) : _x(x) {}

    void execute() override {
        cout << -_x << endl;
    }
};

class Command2 : public ICommand {
private:
    int _x, _y;
public:
    explicit Command2(int x, int y) : _x(x), _y(y) {}

    void execute() override {
        cout << (_x + _y) << endl;
    }
};
```



# 应用

将命令 与 命令的接收者分离，

一个命令的 参数、命令接收者、命令执行 封装到一个可执行类中：执行命令的时候只需要构造一个可调用对象，然后执行它。



说白了就是 C++ 中的可调用对象！！！！
