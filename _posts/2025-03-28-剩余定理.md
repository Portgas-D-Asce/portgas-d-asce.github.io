---
layout: page
tags: 数据结构与算法 组合数学 数论
image: /assets/image/14.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 剩余定理
---

# 剩余定理

## 原理

**本质是构造一个 $R = (x_1, x_2, ..., x_n)$，要求模数两两互质，若模数不两两互质，向量中的部分元素无法求解。**



找到以下几组数方程组的解

$$
\left\{\begin{aligned}
x_1 \equiv 1(mod m_1) \\
x_1 \equiv 0(mod m_2) \\
\\
x_1 \equiv 0(mod m_n)
\end{aligned}\right.

\left\{\begin{aligned}
x_2 \equiv 0(mod m_1) \\
x_2 \equiv 1(mod m_2) \\
\\
x_2 \equiv 0(mod m_n)
\end{aligned}\right.

...
\left\{\begin{aligned}
x_n \equiv 0(mod m_1) \\
x_n \equiv 0(mod m_2) \\
\\
x_n \equiv 1(mod m_n)
\end{aligned}\right.
$$

然后构造出最终解

$$
x = a_1x_1 + a_2x_2 + ... + a_nx_n
$$


## 算法过程

- 求模数的乘积 $mul$
- $tmp_i = mul / m_i$
- $tmp_i = tmp_i * tmp_i ^{-1}$ 在模 $m_i$ 下
- $x = (\sum_{i = 1} ^ {k} {a_n * tmp_i}) \% mul$

## 实现

```cpp
pair<long long, long long> exgcd(long long a, long long b) {
    if(b == 0) return {1, 0};
    auto [x, y] = exgcd(b, a % b);
    return {y, x - a / b * y};
}

long long crt(const vector<long long> &r, const vector<long long> &m) {
    long long n = r.size(), mul = 1;
    for(int i = 0; i < n; ++i) mul *= m[i];

    long long res = 0;
    for(int i = 0; i < n; ++i) {
        long long tmp = mul / m[i];
        auto [x, y] = exgcd(tmp, m[i]);
        tmp = tmp * x % mul;
        res = (res + (r[i] * tmp) % mul) % mul;
    }
    return (res + mul) % mul;
}
```





# 扩展剩余定理

当模数不两两互质时，会导致求解逆元时 $ax + by \equiv 1$ 无整数解，以上求解方法不再适用，需要另寻方法。



## 原理



算法步骤：

- 先对前两个同余式进行合并：计算它们的一个特解，然后构造出通解 $x = x_0 + k * lcm(m1, m2)$ 也就是 $x \equiv x_0 (mod lcm(m_1, m_2))$
- 再将上一步合并出来的同余式与第三个同余式合并
- ...
- 直到最后只剩下一个同余式，其 $x_0$ 即为最终结果。



总之，先求出前两个同余式的通解，然后再与第三个同余式求通解，...，最后与最后一个同余式求通解，即得到整个同余方程组的通解。

## 实现

所有同余式的模数的 $lcm$ 可能很大，`long long` 级别，两个这样的数相乘会溢出，有两种解决方式：

- `__int128`
- 龟速乘法：将乘法转化为加法，期间不断取模，从而防止溢出。
    - 乘法第二个数不能为负数，否则龟速乘法会陷入死循化。



最终求得的是最小整数解，模数范围内的唯一解。

```cpp
// 扩展欧几里德不会溢出？？？？？？
pair<long long, long long> exgcd(long long a, long long b) {
    if(b == 0) return {1, 0};
    auto [x, y] = exgcd(b, a % b);
    return {y, x - a / b * y};
}

//龟速乘，防止溢出，x 为负数时会陷入死循环。
long long smul(long long a, long long x, long long mod) {
    long long res = 0;
    while(x) {
        if(x & 1) res = (res + a) % mod;
        a = (a + a) % mod;
        x >>= 1;
    }
    return res;
}

// 扩展剩余定理
long long excrt(const vector<long long> &r, const vector<long long> &m) {
    int n = r.size();
    long long r0 = r[0], m0 = m[0];
    for(int i = 1; i < n; ++i) {
        long long r1 = r[i], m1 = m[i];
        // 无法整除，则无整数解
        long long d = (r1 - r0) / gcd(m0, m1);
        // 扩展欧几里德求求 “标准式” 特解
        auto [x, y] = exgcd(m0, m1);
        long long tmp = lcm(m0, m1);
        // 特解转化为正数
        x = (x + tmp) % tmp;
        // 使用龟速乘将特解转化为 “非标准式” 特解
        x = smul(d, x, tmp);
        // 带入公式求出方程组的特解
        r0 = (smul(x, m0, tmp) + r0) % tmp;
        // 合并后同余方程的模数
        m0 = lcm(m0, m1);
    }
    return (r0 + m0) % m0;
}
```



# 练习

[P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪](https://www.luogu.com.cn/problem/P1495)

[P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777)

