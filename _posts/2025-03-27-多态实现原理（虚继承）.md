---
layout: page
tags: cpp
image: /assets/image/2.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 多态实现原理（虚继承）
categories: [计算机, CC++]
---

了解以上概念后，非虚继承场景基本就够了。虚继承场景更为复杂，需要了解更多的东西。



为了支持虚继承，编译器做了一些修改，并添加了一些新的东西



# 虚表变化

以下为虚继承情况下的虚表结构，主要有两点变化：

- `base-offset`：直接 （Base2，Base3）或间接（Derive）继承了虚基类的类，虚表头部都额外添加了一个到虚基类对象的偏移量
- 虚基类的派生类中关于虚基类的虚表有点奇怪

```assembly
vtable for Derive:
    .quad   40				; base-offset
    .quad   0				; top-offset
    .quad   typeinfo for Derive
    .quad   Base2::yyy()
    .quad   Derive::~Derive() [complete object destructor]
    .quad   Derive::~Derive() [deleting destructor]
    .quad   24				; base-offset
    .quad   -16				; top-offset
    .quad   typeinfo for Derive
    .quad   non-virtual thunk to Derive::~Derive() [complete object destructor]
    .quad   non-virtual thunk to Derive::~Derive() [deleting destructor]
    .quad   -40				; yyy call-offset
    .quad   -40				; complete & deleting call-offset
    .quad   0				; ddd call-offset
    .quad   0				; www call-offset
    .quad   0				; zzz call-offset
    .quad   0				; xxx call-offset
    .quad   -40				; top-offset
    .quad   typeinfo for Derive
    .quad   Base::xxx()
    .quad   Base::zzz()
    .quad   Base::www()
    .quad   Base::ddd()
    .quad   virtual thunk to Derive::~Derive() [complete object destructor]
    .quad   virtual thunk to Derive::~Derive() [deleting destructor]
    .quad   virtual thunk to Base2::yyy()
vtable for Base2:
    .quad   16
    .quad   0
    .quad   typeinfo for Base2
    .quad   Base2::yyy()
    .quad   Base2::~Base2() [complete object destructor]
    .quad   Base2::~Base2() [deleting destructor]
    .quad   -16
    .quad   -16
    .quad   0
    .quad   0
    .quad   0
    .quad   0
    .quad   -16
    .quad   typeinfo for Base2
    .quad   Base::xxx()
    .quad   Base::zzz()
    .quad   Base::www()
    .quad   Base::ddd()
    .quad   virtual thunk to Base2::~Base2() [complete object destructor]
    .quad   virtual thunk to Base2::~Base2() [deleting destructor]
    .quad   virtual thunk to Base2::yyy()
```



## 析构函数

在虚继承场景中，complete object destructor != base object destructor，可以这么区分

- 负责释放虚基类资源的就是 complete object destructor
- 不负责释放虚基类资源的就是 base object destructor



deleting object destructor 与非虚继承场景一致。



### base object destructor

**虚继承场景只执行本类析构函数，不会调用基类的析构函数**

```assembly
Base3::~Base3() [base object destructor]:
    ...
    # 执行本类析构函数
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    ...
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    # 没有调用基类的析构函数
    nop
    leave
```



### complete object destructor

在大多数场景下，base object destructor 都工作得很好，但在特殊场景下就 hold 不住了。此时就要采取特殊的析构方式 complete object destructor，除了 base object destructor 的基本操作外，还会执行一些额外的操作，最终来完成内存释放任务。

- 执行本类析构函数 `Derived::~Derived()` 中内容
- 调用基类 base object destructor 析构函数 `Base3::~Base3()` `Base2::~Base2()`

- 调用虚基类的 base object destructor 析构函数 `Base::~Base()`

```assembly
Derived::~Derived() [complete object destructor]:
    ...
    # 当前类析构函数中内容
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    ...
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    ...
    # 调用基类析构
    call    Base3::~Base3() [base object destructor]
    ...
    call    Base2::~Base2() [base object destructor]
    ...
    # 调用虚基类析构
    call    Base::~Base() [base object destructor]
```



## virtual thunk

non-virtual thunk 指的是非虚继承，virtual thunk 指的是虚继承

- **两者都是先偏移 this 指针，然后跳转到重写函数**
- **只不过偏移 this 指针的方式不同而已**



虚基类指针的多态使用的是 virtual thunk 实现的，其指令如下：

- `rdi` 中保存的是 this 指针
- `mov     r10, QWORD PTR [rdi]`：从前 8 个字节获取到虚表地址，放到 `r10` 中
- `add     rdi, QWORD PTR [r10-56]`：获取 `deleting destructor` 的 `call-offset`，并对 this 指针进行偏移
- `jmp     .LTHUNK7`：跳转到 `Derive::~Derive() [deleting destructor]`

```assembly
virtual thunk to Derive::~Derive() [deleting destructor]:
    mov     r10, QWORD PTR [rdi]
    add     rdi, QWORD PTR [r10-56]
    jmp     .LTHUNK7
```



> non-virtural thunk 是根据 top-offset 偏移 this 指针的，virtual thunk 为什么不能根据 top-offset 来偏移 this 指针，非要对每一个虚函数搞出一个 call-offset 出来，这样做有什么意义？？？？



# VTT

虚表的表：一个表，表里面的每个元素都指向一个虚表

相当于把一个类的所有虚表集合起来，用的时候会方便点而已？？？



# _ZTC

构造虚表，重新构造出来的表

> 重新构建虚表的原因是什么，为什么之前的虚表为什么不能再用了？？？？？？？
>
> 



> 重新构建的虚表与之前虚表都有哪些地方不同？
>
> - call-offset ？？？
> - destructor 为什么都设置为 0 了？？？？



不同的对象用不同的虚表

- `a = new Derive()` 这种方式产生的对象使用 `Derive` 的虚表
- `new Base2()` 这种方式产生的对象使用 `Base2` 的虚表，`a` 里面也有一个 `Base2` 对象，两者一样吗？不一样！所以要用不同的虚表。
- `new Base3()` 这种方式产生的对象使用 `Base3` 的虚表，`a` 里面也有一个 `Base3` 对象，两者一样吗？不一样！所以要用不同的虚表。



# 对象内存布局

虚继承 Base、Base2、Base3、Derive 类

```bash
# Base 非虚
base2 vptr
base2 data
base3 vptr
base3 data
derived data
base data
# Base 包含虚函数
base2 vptr
base2 data
base3 vptr
base3 data
derived data
base vptrnn
base data
```



# 多态触发过程

```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base_data = 0x11;
};

class Base2 : virtual public Base {
public:
    virtual ~Base2() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base2_data = 0x21;
};

class Base3 : virtual public Base {
public:
    virtual ~Base3() { std::cout << __FUNCTION__ << std::endl; }
    long long m_base2_data = 0x31;
};

class Derive : public Base2, public Base3 {
public:
    virtual ~Derive() { std::cout << __FUNCTION__ << std::endl; }
    long long m_derive_data = 0x41;
};

int main() {
    Base *b = new Derive();
    delete b;
    return 0;
}
```



```assembly
vtable for Derive:
    .quad   40
    .quad   0
    .quad   typeinfo for Derive
    .quad   Derive::~Derive() [complete object destructor]
    .quad   Derive::~Derive() [deleting destructor]
    .quad   24
    .quad   -16
    .quad   typeinfo for Derive
    .quad   non-virtual thunk to Derive::~Derive() [complete object destructor]
    .quad   non-virtual thunk to Derive::~Derive() [deleting destructor]
    .quad   -40
    .quad   -40
    .quad   typeinfo for Derive
    .quad   virtual thunk to Derive::~Derive() [complete object destructor]
    .quad   virtual thunk to Derive::~Derive() [deleting destructor]
VTT for Derive:
    .quad   vtable for Derive+24
    .quad   construction vtable for Base2-in-Derive+24
    .quad   construction vtable for Base2-in-Derive+64
    .quad   construction vtable for Base3-in-Derive+24
    .quad   construction vtable for Base3-in-Derive+64
    .quad   vtable for Derive+104
    .quad   vtable for Derive+64
construction vtable for Base2-in-Derive:
    .quad   40
    .quad   0
    .quad   typeinfo for Base2
    .quad   0
    .quad   0
    .quad   -40
    .quad   -40
    .quad   typeinfo for Base2
    .quad   0
    .quad   0
construction vtable for Base3-in-Derive:
    .quad   24
    .quad   0
    .quad   typeinfo for Base3
    .quad   0
    .quad   0
    .quad   -24
    .quad   -24
    .quad   typeinfo for Base3
    .quad   0
    .quad   0
vtable for Base:
    .quad   0
    .quad   typeinfo for Base
    .quad   Base::~Base() [complete object destructor]
    .quad   Base::~Base() [deleting destructor]
typeinfo for Derive:
    .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
    .quad   typeinfo name for Derive
    .long   2
    .long   2
    .quad   typeinfo for Base2
    .quad   2
    .quad   typeinfo for Base3
    .quad   4098
typeinfo name for Derive:
    .string "6Derive"
typeinfo for Base3:
    .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
    .quad   typeinfo name for Base3
    .long   0
    .long   1
    .quad   typeinfo for Base
    .quad   -6141
typeinfo name for Base3:
    .string "5Base3"
typeinfo for Base2:
    .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
    .quad   typeinfo name for Base2
    .long   0
    .long   1
    .quad   typeinfo for Base
    .quad   -6141
typeinfo name for Base2:
    .string "5Base2"
typeinfo for Base:
    .quad   vtable for __cxxabiv1::__class_type_info+16
    .quad   typeinfo name for Base
typeinfo name for Base:
    .string "4Base"
```



```assembly
.L13:
    mov     QWORD PTR [rbp-24], rax
    mov     rax, QWORD PTR [rbp-24]
    test    rax, rax
    je      .L14					; "this" in rax and point to Base ject
    mov     rdx, QWORD PTR [rax]	; get virtual table from vptr, and store in rdx
    add     rdx, 8					; move rdx to deleting object destructor
    mov     rdx, QWORD PTR [rdx]	; rdx is virtual thunk to Derive::~Derive() [deleting destructor]
    mov     rdi, rax				; store "this" in rdi
    call    rdx						; exec virtual thunk
```



```assembly
virtual thunk to Derive::~Derive() [deleting destructor]:
    mov     r10, QWORD PTR [rdi]	; get vtable from "this" and store in r10
    add     rdi, QWORD PTR [r10-24]	; get call-offset at r10-24 and move "this"
    								; "this" point to Derive object
    jmp     .LTHUNK6
```



```assembly
Derive::~Derive() [deleting destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi	; backup "this" at rbp-8
    mov     rax, QWORD PTR [rbp-8]
    mov     rdi, rax				; "this" not changed
    call    Derive::~Derive() [complete object destructor]
    mov     rax, QWORD PTR [rbp-8]
    mov     esi, 56					; sizeof(Derive) is 56
    mov     rdi, rax				; "this" point to Derive object as before
    call    operator delete(void*, unsigned long)
    leave
    ret
```



```assembly
Derive::~Derive() [complete object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi					; backup "this" at rbp-8
    
    mov     edx, OFFSET FLAT:vtable for Derive+24	; update vptr.Base2
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    
    mov     rax, QWORD PTR [rbp-8]					; update vptr.Base
    add     rax, 40
    mov     edx, OFFSET FLAT:vtable for Derive+104
    mov     QWORD PTR [rax], rdx
    
    mov     edx, OFFSET FLAT:vtable for Derive+64	; update vptr.Base3
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax+16], rdx
    
    mov     esi, OFFSET FLAT:.LC2
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    
    mov     rax, QWORD PTR [rbp-8]					; get "this"
    add     rax, 16									; move "this" to Base3 object
    
    mov     edx, OFFSET FLAT:VTT for Derive+24		; store construction vtable Base3-in-Derive in rsi
    mov     rsi, rdx
    mov     rdi, rax
    call    Base3::~Base3() [base object destructor]
    
    mov     rax, QWORD PTR [rbp-8]					; get "this" and it also point to Base2 object
    mov     edx, OFFSET FLAT:VTT for Derive+8		; store construction vtable Base2-in-Derive in rsi
    mov     rsi, rdx
    mov     rdi, rax
    call    Base2::~Base2() [base object destructor]
    
    mov     rax, QWORD PTR [rbp-8]					; get "this"
    add     rax, 40									; move to Base
    mov     rdi, rax
    call    Base::~Base() [base object destructor]
    nop
    leave
    ret
```



```assembly
Base3::~Base3() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     QWORD PTR [rbp-16], rsi
    mov     rax, QWORD PTR [rbp-16]
    mov     rdx, QWORD PTR [rax]
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     rax, QWORD PTR [rbp-8]
    mov     rax, QWORD PTR [rax]
    sub     rax, 24
    mov     rax, QWORD PTR [rax]
    mov     rdx, rax
    mov     rax, QWORD PTR [rbp-8]
    add     rdx, rax
    mov     rax, QWORD PTR [rbp-16]
    mov     rax, QWORD PTR [rax+8]
    mov     QWORD PTR [rdx], rax
    mov     esi, OFFSET FLAT:.LC2
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    nop
    leave
    ret
```



```assembly
Base2::~Base2() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     QWORD PTR [rbp-16], rsi
    mov     rax, QWORD PTR [rbp-16]
    mov     rdx, QWORD PTR [rax]
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     rax, QWORD PTR [rbp-8]
    mov     rax, QWORD PTR [rax]
    sub     rax, 24
    mov     rax, QWORD PTR [rax]
    mov     rdx, rax
    mov     rax, QWORD PTR [rbp-8]
    add     rdx, rax
    mov     rax, QWORD PTR [rbp-16]
    mov     rax, QWORD PTR [rax+8]
    mov     QWORD PTR [rdx], rax
    mov     esi, OFFSET FLAT:.LC1
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    nop
    leave
    ret
```



```assembly
Base::~Base() [base object destructor]:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     QWORD PTR [rbp-8], rdi
    mov     edx, OFFSET FLAT:vtable for Base+16
    mov     rax, QWORD PTR [rbp-8]
    mov     QWORD PTR [rax], rdx
    mov     esi, OFFSET FLAT:.LC0
    mov     edi, OFFSET FLAT:_ZSt4cout
    call    std::basic_ostream<char, std::char_traits<char> >& std::operator<<...
    mov     esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
    mov     rdi, rax
    call    std::basic_ostream<char, std::char_traits<char> >::operator<<...
    nop
    leave
    ret
```

