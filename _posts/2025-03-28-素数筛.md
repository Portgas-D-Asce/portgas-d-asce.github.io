---
layout: page
tags: 数据结构与算法 数论
image: /assets/image/25.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 素数筛
---

# 素数筛

## 原理

素数筛 利用已找到的素数对范围内的合数进行 **标记** （未被标记的数则为素数）的方式来查找素数。

## 实现

```cpp
vector<int> prime_sieve(int n) {
    //当遍历到 i 时，i 之前的所有合数都已经被标记了吗，会不会存在漏标的情况？
    //不会存在漏标，每个合数都可以写成若干个比它小的素数的乘积（也就是一定被比它小的素数标记过了）
    int idx = 0;
    vector<int> prime(n + 1);
    for(int i = 2; i <= n; ++i) {
        if(prime[i]) continue;
        prime[idx++] = i;
        for(int j = i + i; j <= n; j += i) {
            prime[j] = 1;
        }
    }
    prime.erase(prime.begin() + idx, prime.end());
    return prime;
}
```
每个合数都会被它的素因子 **重复标记** 。例如：
- 12：被 2 标记了一次（12 = 2 + 2 + 2 + 2 + 2 + 2），又被 3 标记了一次（12 = 3 + 3 + 3 + 3）；
- 18：被 2 标记了一次（18 = 2 + 2 + 2 + ... + 2）, 又被 3 标记了一次（18 = 3 + 3 + 3 + 3 + 3 + 3）；



## 复杂度

空间复杂度：$O(n)$；

时间复杂度：$O(nloglogn)$



证明：

> 根据素数分布定理，n 以内的素数约有 $\frac{n}{\ln n}$ 个，第 $i$ 个素数约为 $i\ln i$。

于是，素数筛的时间复杂度约为：
$$
\sum_{i = 2}^{\frac{n}{\ln n}} \frac{n}{i\ln i} = n \sum_{i = 2}^{\frac{n}{\ln n}} \frac{1}{i\ln i}
$$

上述公式可用定积分进行近似：
$$
\begin{aligned}
\sum_{i = 2}^{\frac{n}{\ln n}} \frac{1}{i\ln i} 
& \approx 
\int_{2}^{\frac{n}{\ln n}}\frac{1}{i\ln i} di \\
& =
\ln\ln x |_{2}^{\frac{n}{\ln n}}\\
& = \ln\ln n - \ln\ln\ln n - \ln\ln 2

\end{aligned}
$$

因此，素数筛的时间复杂度为：
$$
\begin{aligned}
O(n \sum_{i = 2}^{\frac{n}{\ln n}} \frac{1}{i\ln i})
& = 
O(n(\ln\ln n - \ln\ln\ln n - \ln\ln 2)) \\
& = 
O(n\ln\ln n)

\end{aligned}
$$



# 线性筛

## 原理

针对 素数筛 重复标记问题，线性筛 对该部分进行了优化，使得每个合数仅被标记一次，即：**合数只会被其最小质因数标记一次**。



## 实现

```cpp
vector<int> linear_sieve(int n) {
    int idx = 0;
    vector<int> prime(n + 1);
    for(int i = 2; i <= n; ++i) {
        if(!prime[i]) prime[idx++] = i;
        for(int j = 0; j < idx; ++j) {
            int x = prime[j] * i;
            if(x > n) break;
            // 用 prime[j] 标记 x
            prime[x] = 1;
            // prime[j] 是 i 的最小质因子
            if(i % prime[j] == 0) break;
        }
    }
    prime.erase(prime.begin() + idx, prime.end());
    return prime;
}
```

以上实现是如何做到 “不遗漏地只标记一次” 的呢？

- 结合以下两点，`if(i % prime[j] == 0) break` 保证了，每个数总是被它的最小素因子标记一次，而不会被其它素因子再次标记

    - 如果 `i % prime[j] != 0` 说明还没到 $i$ 的最小素因子，那么 `prime[j]` 就是 `x = i * prime[j]` 的最小素因子

    - 如果 `i % prime[j] == 0` 说明 `prime[j]` 是 $i$​ 的最小素因子，那么 `prime[j]` 也是 `x = i * prime[j]` 的最小素因子

- 对于任意数 `z` 除以其最小素数 `p` 得到其最大因子 `y < z` 一定会在 `prime[j] == p && i == y` 时被标记，这样也就做到了不遗漏。



## 复杂度

空间复杂度：$O(n)$

时间复杂度：$O(n)$



# 素性检验

## 整除方法



```c
bool is_prime(int x) {
    if(x % 2 == 0) return false;
    for(int i = 3; i * i <= x; i += 2) {
        if(x % i == 0) return false;
    }
    return true;
}
```
时间复杂度：$O(sqrt(n))$



## 米勒-拉宾素性检验(Miller-Rabbin)

还差个这个，看明白再补上。
