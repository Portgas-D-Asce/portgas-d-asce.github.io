# 二分图



二分图中 n 个节点

- 划分为两个不相交的非空集合 $A$ 和 $B$
- 同一集合内部任意两点不相连



> 二分图不存在长度为奇数的环：
>
> - 每条边都是跨集合的
> - 只有偶数条边才能回到初始集合



# 判定

## 染色法

假设图是连通的：

- 起始节点染为初始色
- bfs or dfs，将相邻节点染成相反颜色
- 一旦发现某个节点的颜色与其父节点颜色相同（发生冲突）该图不是二分图
- 遍历完整个图也未发现冲突，则该图为二分图

```cpp
bool isBipartite(vector<vector<int>>& g) {
    int n = g.size();
    vector<int> color(n, -1);
    color[0] = 0;
    
    // 队列中存放已经染过色的节点
    queue<int> que;
    que.push(0);
    while(!que.empty()) {
        int u = que.front();
        que.pop();
        for(int v : g[u]) {
            //发生冲突
            if(color[v] == color[u]) {
                return false;
            }
            //第一次遇见，将其染为与父节点相反的颜色
            if(color[v] == -1) {
                color[v] = !color[u];
                que.push(v);
            }
        }
    }
    return true;
}
```



## 并查集

图最终会被划分为连通分量 * 2 部分

- 遍历所有点
- 将其父节点与子节点合并
- 一旦发现当前节点和父节点/子节点已经合并了，直接返回 false 即可

```c++
int find(int x, vector<int> &uf){
    return uf[x] == x ? x : uf[x] = find(uf[x]);
}

bool isBipartite(vector<vector<int>>& g) {
    int n = g.size();
    vector<int> uf(n);
    for(int i = 0; i < n; i++) {
        uf[i] = i;
    }
    for(int u = 0; u < n; u++) {
        if(g[u].empty()) continue;
        //父节点也在其中，刚好将所有子节点和父节点合并为一类
        int v0 = g[u][0];
        for(int v : g[u]) {
            uf[find(v, uf)] = find(v0, uf);
        }
        if(find(u, uf) == find(v0, uf)) return false;
    }
    return true;
}
```



## 练习

[LeetCode 785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)





# 二分图最小点覆盖

最小点覆盖：选最少的点，满足每条边至少都有一个端点被选

二分图的最小点覆盖 = 二分图的最大匹配



证明？



如何构造？



[http://www.matrix67.com/blog/archives/116](http://www.matrix67.com/blog/archives/116)





# 二分图最小边覆盖

在二分图中，求最少的边，使得它们覆盖所有点，并且每个点只被一条边覆盖



二分图最少边覆盖 = 点数 - 二分图最大匹配



证明：

先贪心选一组最大匹配的边放进集合，对于剩下的点，随便选择一条与之关联的边放进集合，那么得到的集合就是最小边覆盖。

- 为什么每个剩余点都对应一条边，剩余两个点选择一条边？如果这样的话，一开始选的就不是最大匹配

所以：最小边覆盖 = 最大匹配 + 点数 - 2 * 最大匹配 = 点数 - 最大匹配                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               



# 二分图最大独立集

在二分图中，选最多的点，使得任意两个点之间没有直接边连接



二分图的最大独立集 = 点数 - 二分图的最小点覆盖



先把所有点放进集合，然后删除最少的点和与之关联的边，使得全部边都被删完，这就是最小覆盖点



