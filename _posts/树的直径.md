# 概述

## 性质

若树上所有边边权均为正，则树的所有直径中点重合

证明：使用反证法。设两条中点不重合的直径分别为 ![\delta(s,t)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 与 ![\delta(s',t')](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，中点分别为 ![x](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 与 ![x'](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。显然，![\delta(s,x) = \delta(x,t) = \delta(s',x') = \delta(x',t')](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。

![无负权边的树所有直径的中点重合](https://oi-wiki.org/graph/images/tree-diameter4.svg)

有 ![\delta(s,t') = \delta(s,x) + \delta(x,x') + \delta(x',t') > \delta(s,x) + \delta(x,t) = \delta(s,t)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，与 ![\delta(s,t)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 为树上任意两节点之间最长的简单路径矛盾，故性质得证。



# 不带权重

当不带权重时，可以采用拓扑排序的方式



从入度为 1 的节点开始，一层一层剥离，记录下最后剩余节点的奇偶性，则最长直径为： 层数 * 2 - 是否为奇数 - 1



# 带权重

要求权重值非负，求解步骤：

- 选择任意节点为起点，求距离其最远的节点 x
- 以 x 为起点，求距离其最远的节点 y
- x，y 之间的路径便是一条直径

```cpp
class Solution {
private:
    void dfs(vector<vector<int>> &g, int u, int p, int cur, vector<int> &dist) {
        for(int v : g[u]) {
            if(v == p) continue;
            dist[v] = cur + 1;
            dfs(g, v, u, cur + 1, dist);
        }
    }
public:
    int treeDiameter(vector<vector<int>>& edges) {
        if(edges.empty()) return 0;
        int n = edges.size() + 1;
        vector<vector<int>> g(n);
        for(auto &edge : edges) {
            int u = edge[0];
            int v = edge[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        vector<int> dist(n);
        dfs(g, 0, 0, 0, dist);
        int mx = 0, idx = -1;
        for(int i = 0; i < n; ++i) {
            if(dist[i] > mx) {
                mx = dist[i];
                idx = i;
            }
        }

        for(int i = 0; i < n; ++i) {
            dist[i] = 0;
        }
        dfs(g, idx, idx, 0, dist);
        mx = 0;
        for(int i = 0; i< n; ++i) {
            mx = max(mx, dist[i]);
        }
        return mx;
    }
};
```



# 练习

[1245. 树的直径](https://leetcode.cn/problems/tree-diameter/)

