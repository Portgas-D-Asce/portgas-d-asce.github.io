---
layout: page
image: /assets/image/48.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 外观模式（Facade）
categories: [计算机, 设计模式]
---

# 概述

对外部提供稳定的接口，避免过度耦合（外部依赖内部的具体实现）



## 动机

![/assets/content/14.png](/assets/content/14.png)



用户和子系统存在过多的耦合，无论是用户还是子系统，更新迭代起来很容易发生冲突。



如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦



## 定义

为子系统中的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。



## 类图

![/assets/content/15.png](/assets/content/15.png)

# 实现

```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

class Server {
public:
    void func1() {
        cout << "server func1" << endl;
    }
    void func2() {
        cout << "server func2" << endl;
    }

    void func3() {
        cout << "server func3" << endl;
    }
};

class Facade {
private:
    Server _server;
public:
    Facade() : _server(Server()) {}

    void deal(const string& msg) {
        _server.func1();
        _server.func2();
        _server.func3();
        cout << msg << endl;
    }
};


int main() {
    Facade f;
    f.deal("Hello World!");
    return 0;
}
```





# 应用

本质就是 “解耦用户与子系统之间的关系”

- 用户不关心子系统内部如何处理，只关注结果
- 子系统只提供稳定的接口，演进起来更灵活。



从客户程序的角度来看， Facade 模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦” 的效果：内部子系统的任何变化不会影响到 Facade 接口的变化



Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade 很多时候更是一种架构设计模式。



Facade 设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade 模式中组件的内部应该是 “相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。
