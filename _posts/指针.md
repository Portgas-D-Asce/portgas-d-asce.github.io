# 数组指针

以 `c[2][10]`  为例

数组名的双层含义：

- **表示一个数组变量：** 
    - c 表示一个类型为 `int[2][10]` 的数组变量，sizeof 会获取该数组变量的字节数
    - &c 表示对数组变量取地址，获得一个指向 `int[2][10]` 类型的数组指针
- **表示一个指针：**
    - c 可以理解成一个指针，指向的类型为数组中元素的类型。
    - 这里元素的类型为 `int[10]`，故 c 可以理解为一个指向 `int[10]` 类型的数组指针



c[0] 的含义：表示数组中第一个元素，是一个 `int[10]` 类型的数组变量

- **表示一个数组变量：** `sizeof(c[0]) = ?`，`&c[0] = ?`，`&c[0] + 1 = ?`
- **表示一个指针：** `c[0] = ?`，`c[0] + 1 = ?`



指针的指针 `int **p` ：一个指向 `int *` 类型指针的指针



注意：虽然都指向数组的起始地址，但指针的含义是不一样的



```c

```



> `int *p[10]` 、 `int (*p)[10]` 、`int **p[10]` 、 `int (**p)[10]` 
>
> - 一个数组，每个元素都是一个指针
> - 一个指针，一个指向数组的指针
> - 一个数组，每个元素都是一个指向指针的指针
> - 一个指针，指向指针的指针，最底层指针是一个数组指针



> 如何接收多维数组
>
> - `int func(int mat[3][10])`
> - `int func(int mat[][10], int n)`
> - `int func(int (*mat)[10], int n)`



# 函数指针

函数名：表示一个函数变量，对一个函数变量取地址便得到一个函数指针

- 函数名和函数指针都指向函数的起始位置
- 函数名和函数指针都可以直接用来调用函数
- 函数变量无法使用 sizeof 运算符
- 函数指针无法使用自增自减运算符
- 函数指针可以作为参数传递



```c
//声明一个函数指针
int (* padd)(int, int) = &add;

//声明一个函数类型
typedef int(* Fiiip)(int, int);
Fiiip ptr = &add;
```



```cpp
#include <stdio.h>

typedef int(* Fiiip)(int, int);

int add(int a, int b) {
    return a + b;
}

int main() {
    printf("add = %p, &add = %p\n", add, &add);
    printf("add(2, 3) = %d\n", add(2, 3));
    printf("(&add)(2, 3) = %d\n", (&add)(2, 3));
    
    //int (* padd)(int, int) = add;
    int (* padd)(int, int) = &add;
    printf("padd(2, 3) = %d\n", padd(2, 3));
    printf("(*padd)(2, 3) = %d\n", (*padd)(2, 3));
    
    //Fiiip ptr = add;
    Fiiip ptr = &add;
    printf("ptr(2, 3) = %d\n", ptr(2, 3));
    printf("(*ptr)(2, 3) = %d\n", (*ptr)(2, 3));
    return 0;
}

/*
add = 0x1047cfda4, &add = 0x1047cfda4
add(2, 3) = 5
(&add)(2, 3) = 5
padd(2, 3) = 5
(*padd)(2, 3) = 5
ptr(2, 3) = 5
(*ptr)(2, 3) = 5
*/
```



> `int* fun(int x,int y)` 和 `int (*fun)(int x,int y)` 的区别。



感兴趣的同学可以看看下面这个用法，并尝试理解该表达式是如何使用的函数指针。

```text
(* (void(*)()) 0)(); //出自《C Trap and Pitfalls》这本经典的书
```

**答案如下**： ``

- 第一步：通过`void(*) ()`，可以明白这是一个函数指针类型。这个函数没有参数，没有返回值。
- 第二步：通过`(void(*) ())0`，可以明白这是将`0`强制转换为函数指针类型，`0`是一个地址，也就是说一个函数存在首地址为`0`的一段区域内。
- 第三步：通过`(*(void(*) ())0)`，可以明白这是取0地址开始的一段内存里面的内容。
- 第四步：最终理解`(*(void(*) ())0)()`，这是函数调用。



**让程序跳转到绝对地址为`0x0113F90C`**

方法一：

- 将`0x0113F90C`地址强制转换为函数指针类型,即: `(void (*)())0x0113F90C`
- 然后调用：`((void (*)())0x0113F90C)()`

方法二：

```text
typedef (void (*)())  VoidFuncPtr;
((VoidFuncPtr)0x0113F90C)();
```



## 成员函数指针

```cpp
//指向类成员函数的函数指针
#include <iostream>
#include <cstdio>
using namespace std;
 
class A
{
    public:
        A(int aa = 0):a(aa){}
 
        ~A(){}
 
        void setA(int aa = 1)
        {
            a = aa;
        }
        
        virtual void print()
        {
            cout << "A: " << a << endl;
        }
 
        virtual void printa()
        {
            cout << "A1: " << a << endl;
        }
    private:
        int a;
};
 
class B:public A
{
    public:
        B():A(), b(0){}
        
        B(int aa, int bb):A(aa), b(bb){}
 
        ~B(){}
 
        virtual void print()
        {
            A::print();
            cout << "B: " << b << endl;
        }
 
        virtual void printa()
        {
            A::printa();
            cout << "B: " << b << endl;
        }
    private:
        int b;
};
 
int main(void)
{
    A a;
    B b;
    void (A::*ptr)(int) = &A::setA;
    A* pa = &a;
    
    //对于非虚函数，返回其在内存的真实地址
    printf("A::set(): %p\n", &A::setA);
    //对于虚函数， 返回其在虚函数表的偏移位置
    printf("B::print(): %p\n", &A::print);
    printf("B::print(): %p\n", &A::printa);
 
    a.print();
 
    a.setA(10);
 
    a.print();
 
    a.setA(100);
 
    a.print();
    //对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用
    (pa->*ptr)(1000);
 
    a.print();
 
    (a.*ptr)(10000);
 
    a.print();
    return 0;
}
```

