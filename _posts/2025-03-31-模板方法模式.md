---
layout: page
tags: 设计模式
image: /assets/image/22.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 模板方法模式
categories: [计算机, 设计模式]
---


# 概述

## 动机

对于某一类任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因而无法和任务的整体结构同时实现



如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的灵活变化或者晚期实现需求？



## 定义

定义一个操作中的算法骨架（稳定），而将一些子步骤延迟到子类中。Template Method 使得子类可以不改变（复用）一个算法的结构即可重定义（override 重写）该算法的某些步骤。



## 类图

![/assets/content/2.png](/assets/content/2.png)



# 实现

## 非 Template Method

```cpp
#include <iostream>
using namespace std;

class ITemplate {
public:
    virtual ~ITemplate() = default;
    void func2() {
        cout << "func2" << endl;
    }
    void func3() {
        cout << "func3" << endl;
    }
    virtual void run() = 0;
};

class Template1 : public ITemplate {
    void func1() {
        cout << "Template1::func1" << endl;
    }

    void func4() {
        cout << "Template1::func4" << endl;
    }

    void run() override {
        func1();
        func2();
        func3();
        func4();
    }
};

class Template2 : public ITemplate {
    void func1() {
        cout << "Template2::func1" << endl;
    }

    void func4() {
        cout << "Template2::func4" << endl;
    }

    void run() override {
        func1();
        func2();
        func3();
        func4();
    }
};

int main() {
    ITemplate* temp1 = new Template1();
    temp1->run();

    cout << endl;

    ITemplate* temp2 = new Template2();
    temp2->run();

    return 0;
}
```

用户除了关心 “变化” 的部分，还需要关注整个 run 方法的执行流程，但实际上 run 方法的执行流程时 “稳定” 的，用户完全没有必要关心。



## 模版方法模式

```cpp
#include <iostream>
using namespace std;

class ITemplate {
public:
    virtual ~ITemplate() = default;
    virtual void func1() = 0;

    void func2() {
        cout << "func2" << endl;
    }

    void func3() {
        cout << "func3" << endl;
    }

    virtual void func4() = 0;

    // Template Method
    void run() {
        func1();
        func2();
        func3();
        func4();
    }
};

class Template1 : public ITemplate {
    void func1() override {
        cout << "Template1::func1" << endl;
    }

    void func4() override {
        cout << "Template1::func4" << endl;
    }
};

class Template2 : public ITemplate {
    void func1() override {
        cout << "Template2::func1" << endl;
    }

    void func4() override {
        cout << "Template2::func4" << endl;
    }
};

int main() {
    ITemplate* temp1 = new Template1();
    temp1->run();

    cout << endl;

    ITemplate* temp2 = new Template2();
    temp2->run();

    return 0;
}
```

用户只需要对 “变化” 的部分进行重新实现，而不必关心整个方法的具体执行流程。



# 应用

## 升级流程

```cpp
#include <iostream>
using namespace std;

class IUpgrade {
public:
    virtual ~IUpgrade() = default;

    virtual void pre_uninstall() = 0;
    void uninstall() {
        cout << "uninstall" << endl;
    }
    virtual void post_uninstall() = 0;

    virtual void pre_install() = 0;
    void install() {
        cout << "install" << endl;
    }
    virtual void post_install() = 0;

    void upgrade() {
        // 卸载旧软件包前，处理步骤
        pre_uninstall();
        // 卸载旧软件包
        uninstall();
        // 卸载旧软件包后，处理步骤
        post_uninstall();

        // 安装新软件包前，处理步骤
        pre_install();
        // 安装新软件包
        install();
        // 安装新软件包后，处理步骤
        post_install();
    }
};

class Upgrade1 : public IUpgrade {
    void pre_uninstall() override {
        cout << "Upgrade1::pre_uninstall" << endl;
    }

    void post_uninstall() override {
        cout << "Upgrade1::post_uninstall" << endl;
    }

    void pre_install() override {
        cout << "Upgrade1::pre_install" << endl;
    }

    void post_install() override {
        cout << "Upgrade1::post_install" << endl;
    }
};

class Upgrade2 : public IUpgrade {
    void pre_uninstall() override {
        cout << "Upgrade2::pre_uninstall" << endl;
    }

    void post_uninstall() override {
        cout << "Upgrade2::post_uninstall" << endl;
    }

    void pre_install() override {
        cout << "Upgrade2::pre_install" << endl;
    }

    void post_install() override {
        cout << "Upgrade2::post_install" << endl;
    }
};

int main() {
    IUpgrade* upg1 = new Upgrade1();
    upg1->upgrade();

    cout << endl;

    IUpgrade* upg2 = new Upgrade2();
    upg2->upgrade();

    return 0;
}
```

