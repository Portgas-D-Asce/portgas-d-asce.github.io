---
layout: page
tags: 计算几何
image: /assets/image/47.jpeg
description: xxxxxxxxxxxxxxxxxx
author: pk
title: 凸包
categories: [计算机, 数据结构与算法]
---

# 二维凸包

## 概述

### 凸多边形

所有内角大小都在 $[0, \pi]$ 范围内的简单多边形。

### 凸包

平面上能包含所有给定点的最小凸多边形叫做凸包。



在包含所有点的多边形中（可能是凸多边形，也可能不是凸多边形），凸包的周长是最短的



小于 4 个点直接就是凸包，点和线短可以看作是特殊的凸包



## Andrew

### 原理

先对点排序，第一个点和最后一个点一定在凸包上

- 从前往后遍历，使用外积找到下凸包
- 从后往前遍历，使用外积找到上凸包



### 实现

当前点与栈顶两个点的外积小于 0 时，需要不断弹出栈顶，直到剩下一个元素为止

```cpp
// (p1, p2) x (p1, p3)
template<typename T>
T cross(const pair<T, T> &p1, const pair<T, T> &p2, const pair<T, T> &p3) {
    return (p2.first - p1.first) * (p3.second - p1.second) -
           (p3.first - p1.first) * (p2.second - p1.second);
}

// 返回值末尾包含起点
template<typename T>
vector<pair<T, T>> andrew(vector<pair<T, T>> &pts) {
    // 0 个点和 1 个点都返回点集自身
    if(pts.size() < 2) return pts;
    
    // 包含 2 个点、3 个点情况，且都会追加起始点
    auto start = [&pts](int p, int r, vector<pair<T, T>> &stk) {
        int step = p < r ? 1 : -1;
        int base = stk.size() + (step > 0);
        for(int i = p; i != r; i += step) {
            for(int j = stk.size(); j > base; --j) {
                if(cross(stk[j - 1], stk[j - 2], pts[i]) < 0) break;
                stk.pop_back();
            }
            stk.push_back(pts[i]);
        }
    };
    
    sort(pts.begin(), pts.end());

    int n = pts.size();
    vector<pair<T, T>> res;
    start(0, n, res);
    start(n - 2, -1, res);
    return res;
}
```



### 复杂度

时间复杂度：$O(nlog(n))$

空间复杂度：$O(O(n))$​



## Graham

### 原理

从凸包上任意点出发，逆时针按照极角从小到大遍历，凸包上相邻 3 点的外积 >= 0



步骤：

- 选择起始点：要求改点在凸包上即可，选择的点的不同会导致极角的取值范围不同
    - 选取 y 轴最小的点时，极角的取值范围 $[0, \pi]$
    - 选取 x 轴最小的点时，极角的取值范围 $[-\pi / 2, \pi / 2]$​
    - 显然，为了简化计算，还是选择 “最值点”。
- 按极角排序：计算其余点与起始点连线的极角，并按照大小进行排序。



### 实现

注意：实现时，没必要真的把极角计算出来，只需要比较出相对大小，例如使用外积，但需注意 0 和 180 度也要能正确比较大小。

andrew 已经很好用了，就不... &#x1F602; &#x1F602;



### 复杂度

时间复杂度：$O(nlog(n))$

空间复杂度：$O(n)$



# 三维凸包





# 练习

[P2742 [USACO5.1] 圈奶牛Fencing the Cows /【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)
